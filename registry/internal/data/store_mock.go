package data

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"

	"oss.indeed.com/go/modprox/pkg/clients/payloads"
	"oss.indeed.com/go/modprox/pkg/coordinates"
	"oss.indeed.com/go/modprox/pkg/netservice"
)

// StoreMock implements Store
type StoreMock struct {
	t minimock.Tester

	funcDeleteModuleByID          func(id int) (err error)
	afterDeleteModuleByIDCounter  uint64
	beforeDeleteModuleByIDCounter uint64
	DeleteModuleByIDMock          mStoreMockDeleteModuleByID

	funcInsertModules          func(ma1 []coordinates.Module) (i1 int, err error)
	afterInsertModulesCounter  uint64
	beforeInsertModulesCounter uint64
	InsertModulesMock          mStoreMockInsertModules

	funcListHeartbeats          func() (ha1 []payloads.Heartbeat, err error)
	afterListHeartbeatsCounter  uint64
	beforeListHeartbeatsCounter uint64
	ListHeartbeatsMock          mStoreMockListHeartbeats

	funcListModuleIDs          func() (ia1 []int64, err error)
	afterListModuleIDsCounter  uint64
	beforeListModuleIDsCounter uint64
	ListModuleIDsMock          mStoreMockListModuleIDs

	funcListModules          func() (sa1 []coordinates.SerialModule, err error)
	afterListModulesCounter  uint64
	beforeListModulesCounter uint64
	ListModulesMock          mStoreMockListModules

	funcListModulesByIDs          func(ids []int64) (sa1 []coordinates.SerialModule, err error)
	afterListModulesByIDsCounter  uint64
	beforeListModulesByIDsCounter uint64
	ListModulesByIDsMock          mStoreMockListModulesByIDs

	funcListModulesBySource          func(source string) (sa1 []coordinates.SerialModule, err error)
	afterListModulesBySourceCounter  uint64
	beforeListModulesBySourceCounter uint64
	ListModulesBySourceMock          mStoreMockListModulesBySource

	funcListStartConfigs          func() (ca1 []payloads.Configuration, err error)
	afterListStartConfigsCounter  uint64
	beforeListStartConfigsCounter uint64
	ListStartConfigsMock          mStoreMockListStartConfigs

	funcPurgeProxy          func(instance netservice.Instance) (err error)
	afterPurgeProxyCounter  uint64
	beforePurgeProxyCounter uint64
	PurgeProxyMock          mStoreMockPurgeProxy

	funcSetHeartbeat          func(h1 payloads.Heartbeat) (err error)
	afterSetHeartbeatCounter  uint64
	beforeSetHeartbeatCounter uint64
	SetHeartbeatMock          mStoreMockSetHeartbeat

	funcSetStartConfig          func(c1 payloads.Configuration) (err error)
	afterSetStartConfigCounter  uint64
	beforeSetStartConfigCounter uint64
	SetStartConfigMock          mStoreMockSetStartConfig
}

// NewStoreMock returns a mock for Store
func NewStoreMock(t minimock.Tester) *StoreMock {
	m := &StoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteModuleByIDMock = mStoreMockDeleteModuleByID{mock: m}
	m.DeleteModuleByIDMock.callArgs = []*StoreMockDeleteModuleByIDParams{}

	m.InsertModulesMock = mStoreMockInsertModules{mock: m}
	m.InsertModulesMock.callArgs = []*StoreMockInsertModulesParams{}

	m.ListHeartbeatsMock = mStoreMockListHeartbeats{mock: m}

	m.ListModuleIDsMock = mStoreMockListModuleIDs{mock: m}

	m.ListModulesMock = mStoreMockListModules{mock: m}

	m.ListModulesByIDsMock = mStoreMockListModulesByIDs{mock: m}
	m.ListModulesByIDsMock.callArgs = []*StoreMockListModulesByIDsParams{}

	m.ListModulesBySourceMock = mStoreMockListModulesBySource{mock: m}
	m.ListModulesBySourceMock.callArgs = []*StoreMockListModulesBySourceParams{}

	m.ListStartConfigsMock = mStoreMockListStartConfigs{mock: m}

	m.PurgeProxyMock = mStoreMockPurgeProxy{mock: m}
	m.PurgeProxyMock.callArgs = []*StoreMockPurgeProxyParams{}

	m.SetHeartbeatMock = mStoreMockSetHeartbeat{mock: m}
	m.SetHeartbeatMock.callArgs = []*StoreMockSetHeartbeatParams{}

	m.SetStartConfigMock = mStoreMockSetStartConfig{mock: m}
	m.SetStartConfigMock.callArgs = []*StoreMockSetStartConfigParams{}

	return m
}

type mStoreMockDeleteModuleByID struct {
	mock               *StoreMock
	defaultExpectation *StoreMockDeleteModuleByIDExpectation
	expectations       []*StoreMockDeleteModuleByIDExpectation

	callArgs []*StoreMockDeleteModuleByIDParams
	mutex    sync.RWMutex
}

// StoreMockDeleteModuleByIDExpectation specifies expectation struct of the Store.DeleteModuleByID
type StoreMockDeleteModuleByIDExpectation struct {
	mock    *StoreMock
	params  *StoreMockDeleteModuleByIDParams
	results *StoreMockDeleteModuleByIDResults
	Counter uint64
}

// StoreMockDeleteModuleByIDParams contains parameters of the Store.DeleteModuleByID
type StoreMockDeleteModuleByIDParams struct {
	id int
}

// StoreMockDeleteModuleByIDResults contains results of the Store.DeleteModuleByID
type StoreMockDeleteModuleByIDResults struct {
	err error
}

// Expect sets up expected params for Store.DeleteModuleByID
func (mmDeleteModuleByID *mStoreMockDeleteModuleByID) Expect(id int) *mStoreMockDeleteModuleByID {
	if mmDeleteModuleByID.mock.funcDeleteModuleByID != nil {
		mmDeleteModuleByID.mock.t.Fatalf("StoreMock.DeleteModuleByID mock is already set by Set")
	}

	if mmDeleteModuleByID.defaultExpectation == nil {
		mmDeleteModuleByID.defaultExpectation = &StoreMockDeleteModuleByIDExpectation{}
	}

	mmDeleteModuleByID.defaultExpectation.params = &StoreMockDeleteModuleByIDParams{id}
	for _, e := range mmDeleteModuleByID.expectations {
		if minimock.Equal(e.params, mmDeleteModuleByID.defaultExpectation.params) {
			mmDeleteModuleByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModuleByID.defaultExpectation.params)
		}
	}

	return mmDeleteModuleByID
}

// Return sets up results that will be returned by Store.DeleteModuleByID
func (mmDeleteModuleByID *mStoreMockDeleteModuleByID) Return(err error) *StoreMock {
	if mmDeleteModuleByID.mock.funcDeleteModuleByID != nil {
		mmDeleteModuleByID.mock.t.Fatalf("StoreMock.DeleteModuleByID mock is already set by Set")
	}

	if mmDeleteModuleByID.defaultExpectation == nil {
		mmDeleteModuleByID.defaultExpectation = &StoreMockDeleteModuleByIDExpectation{mock: mmDeleteModuleByID.mock}
	}
	mmDeleteModuleByID.defaultExpectation.results = &StoreMockDeleteModuleByIDResults{err}
	return mmDeleteModuleByID.mock
}

//Set uses given function f to mock the Store.DeleteModuleByID method
func (mmDeleteModuleByID *mStoreMockDeleteModuleByID) Set(f func(id int) (err error)) *StoreMock {
	if mmDeleteModuleByID.defaultExpectation != nil {
		mmDeleteModuleByID.mock.t.Fatalf("Default expectation is already set for the Store.DeleteModuleByID method")
	}

	if len(mmDeleteModuleByID.expectations) > 0 {
		mmDeleteModuleByID.mock.t.Fatalf("Some expectations are already set for the Store.DeleteModuleByID method")
	}

	mmDeleteModuleByID.mock.funcDeleteModuleByID = f
	return mmDeleteModuleByID.mock
}

// When sets expectation for the Store.DeleteModuleByID which will trigger the result defined by the following
// Then helper
func (mmDeleteModuleByID *mStoreMockDeleteModuleByID) When(id int) *StoreMockDeleteModuleByIDExpectation {
	if mmDeleteModuleByID.mock.funcDeleteModuleByID != nil {
		mmDeleteModuleByID.mock.t.Fatalf("StoreMock.DeleteModuleByID mock is already set by Set")
	}

	expectation := &StoreMockDeleteModuleByIDExpectation{
		mock:   mmDeleteModuleByID.mock,
		params: &StoreMockDeleteModuleByIDParams{id},
	}
	mmDeleteModuleByID.expectations = append(mmDeleteModuleByID.expectations, expectation)
	return expectation
}

// Then sets up Store.DeleteModuleByID return parameters for the expectation previously defined by the When method
func (e *StoreMockDeleteModuleByIDExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockDeleteModuleByIDResults{err}
	return e.mock
}

// DeleteModuleByID implements Store
func (mmDeleteModuleByID *StoreMock) DeleteModuleByID(id int) (err error) {
	mm_atomic.AddUint64(&mmDeleteModuleByID.beforeDeleteModuleByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModuleByID.afterDeleteModuleByIDCounter, 1)

	params := &StoreMockDeleteModuleByIDParams{id}

	// Record call args
	mmDeleteModuleByID.DeleteModuleByIDMock.mutex.Lock()
	mmDeleteModuleByID.DeleteModuleByIDMock.callArgs = append(mmDeleteModuleByID.DeleteModuleByIDMock.callArgs, params)
	mmDeleteModuleByID.DeleteModuleByIDMock.mutex.Unlock()

	for _, e := range mmDeleteModuleByID.DeleteModuleByIDMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModuleByID.DeleteModuleByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModuleByID.DeleteModuleByIDMock.defaultExpectation.Counter, 1)
		want := mmDeleteModuleByID.DeleteModuleByIDMock.defaultExpectation.params
		got := StoreMockDeleteModuleByIDParams{id}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeleteModuleByID.t.Errorf("StoreMock.DeleteModuleByID got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeleteModuleByID.DeleteModuleByIDMock.defaultExpectation.results
		if results == nil {
			mmDeleteModuleByID.t.Fatal("No results are set for the StoreMock.DeleteModuleByID")
		}
		return (*results).err
	}
	if mmDeleteModuleByID.funcDeleteModuleByID != nil {
		return mmDeleteModuleByID.funcDeleteModuleByID(id)
	}
	mmDeleteModuleByID.t.Fatalf("Unexpected call to StoreMock.DeleteModuleByID. %v", id)
	return
}

// DeleteModuleByIDAfterCounter returns a count of finished StoreMock.DeleteModuleByID invocations
func (mmDeleteModuleByID *StoreMock) DeleteModuleByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModuleByID.afterDeleteModuleByIDCounter)
}

// DeleteModuleByIDBeforeCounter returns a count of StoreMock.DeleteModuleByID invocations
func (mmDeleteModuleByID *StoreMock) DeleteModuleByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModuleByID.beforeDeleteModuleByIDCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.DeleteModuleByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModuleByID *mStoreMockDeleteModuleByID) Calls() []*StoreMockDeleteModuleByIDParams {
	mmDeleteModuleByID.mutex.RLock()

	argCopy := make([]*StoreMockDeleteModuleByIDParams, len(mmDeleteModuleByID.callArgs))
	copy(argCopy, mmDeleteModuleByID.callArgs)

	mmDeleteModuleByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModuleByIDDone returns true if the count of the DeleteModuleByID invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockDeleteModuleByIDDone() bool {
	for _, e := range m.DeleteModuleByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModuleByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteModuleByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModuleByID != nil && mm_atomic.LoadUint64(&m.afterDeleteModuleByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteModuleByIDInspect logs each unmet expectation
func (m *StoreMock) MinimockDeleteModuleByIDInspect() {
	for _, e := range m.DeleteModuleByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.DeleteModuleByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModuleByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteModuleByIDCounter) < 1 {
		if m.DeleteModuleByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.DeleteModuleByID")
		} else {
			m.t.Errorf("Expected call to StoreMock.DeleteModuleByID with params: %#v", *m.DeleteModuleByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModuleByID != nil && mm_atomic.LoadUint64(&m.afterDeleteModuleByIDCounter) < 1 {
		m.t.Error("Expected call to StoreMock.DeleteModuleByID")
	}
}

type mStoreMockInsertModules struct {
	mock               *StoreMock
	defaultExpectation *StoreMockInsertModulesExpectation
	expectations       []*StoreMockInsertModulesExpectation

	callArgs []*StoreMockInsertModulesParams
	mutex    sync.RWMutex
}

// StoreMockInsertModulesExpectation specifies expectation struct of the Store.InsertModules
type StoreMockInsertModulesExpectation struct {
	mock    *StoreMock
	params  *StoreMockInsertModulesParams
	results *StoreMockInsertModulesResults
	Counter uint64
}

// StoreMockInsertModulesParams contains parameters of the Store.InsertModules
type StoreMockInsertModulesParams struct {
	ma1 []coordinates.Module
}

// StoreMockInsertModulesResults contains results of the Store.InsertModules
type StoreMockInsertModulesResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Store.InsertModules
func (mmInsertModules *mStoreMockInsertModules) Expect(ma1 []coordinates.Module) *mStoreMockInsertModules {
	if mmInsertModules.mock.funcInsertModules != nil {
		mmInsertModules.mock.t.Fatalf("StoreMock.InsertModules mock is already set by Set")
	}

	if mmInsertModules.defaultExpectation == nil {
		mmInsertModules.defaultExpectation = &StoreMockInsertModulesExpectation{}
	}

	mmInsertModules.defaultExpectation.params = &StoreMockInsertModulesParams{ma1}
	for _, e := range mmInsertModules.expectations {
		if minimock.Equal(e.params, mmInsertModules.defaultExpectation.params) {
			mmInsertModules.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertModules.defaultExpectation.params)
		}
	}

	return mmInsertModules
}

// Return sets up results that will be returned by Store.InsertModules
func (mmInsertModules *mStoreMockInsertModules) Return(i1 int, err error) *StoreMock {
	if mmInsertModules.mock.funcInsertModules != nil {
		mmInsertModules.mock.t.Fatalf("StoreMock.InsertModules mock is already set by Set")
	}

	if mmInsertModules.defaultExpectation == nil {
		mmInsertModules.defaultExpectation = &StoreMockInsertModulesExpectation{mock: mmInsertModules.mock}
	}
	mmInsertModules.defaultExpectation.results = &StoreMockInsertModulesResults{i1, err}
	return mmInsertModules.mock
}

//Set uses given function f to mock the Store.InsertModules method
func (mmInsertModules *mStoreMockInsertModules) Set(f func(ma1 []coordinates.Module) (i1 int, err error)) *StoreMock {
	if mmInsertModules.defaultExpectation != nil {
		mmInsertModules.mock.t.Fatalf("Default expectation is already set for the Store.InsertModules method")
	}

	if len(mmInsertModules.expectations) > 0 {
		mmInsertModules.mock.t.Fatalf("Some expectations are already set for the Store.InsertModules method")
	}

	mmInsertModules.mock.funcInsertModules = f
	return mmInsertModules.mock
}

// When sets expectation for the Store.InsertModules which will trigger the result defined by the following
// Then helper
func (mmInsertModules *mStoreMockInsertModules) When(ma1 []coordinates.Module) *StoreMockInsertModulesExpectation {
	if mmInsertModules.mock.funcInsertModules != nil {
		mmInsertModules.mock.t.Fatalf("StoreMock.InsertModules mock is already set by Set")
	}

	expectation := &StoreMockInsertModulesExpectation{
		mock:   mmInsertModules.mock,
		params: &StoreMockInsertModulesParams{ma1},
	}
	mmInsertModules.expectations = append(mmInsertModules.expectations, expectation)
	return expectation
}

// Then sets up Store.InsertModules return parameters for the expectation previously defined by the When method
func (e *StoreMockInsertModulesExpectation) Then(i1 int, err error) *StoreMock {
	e.results = &StoreMockInsertModulesResults{i1, err}
	return e.mock
}

// InsertModules implements Store
func (mmInsertModules *StoreMock) InsertModules(ma1 []coordinates.Module) (i1 int, err error) {
	mm_atomic.AddUint64(&mmInsertModules.beforeInsertModulesCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertModules.afterInsertModulesCounter, 1)

	params := &StoreMockInsertModulesParams{ma1}

	// Record call args
	mmInsertModules.InsertModulesMock.mutex.Lock()
	mmInsertModules.InsertModulesMock.callArgs = append(mmInsertModules.InsertModulesMock.callArgs, params)
	mmInsertModules.InsertModulesMock.mutex.Unlock()

	for _, e := range mmInsertModules.InsertModulesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsertModules.InsertModulesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertModules.InsertModulesMock.defaultExpectation.Counter, 1)
		want := mmInsertModules.InsertModulesMock.defaultExpectation.params
		got := StoreMockInsertModulesParams{ma1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInsertModules.t.Errorf("StoreMock.InsertModules got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmInsertModules.InsertModulesMock.defaultExpectation.results
		if results == nil {
			mmInsertModules.t.Fatal("No results are set for the StoreMock.InsertModules")
		}
		return (*results).i1, (*results).err
	}
	if mmInsertModules.funcInsertModules != nil {
		return mmInsertModules.funcInsertModules(ma1)
	}
	mmInsertModules.t.Fatalf("Unexpected call to StoreMock.InsertModules. %v", ma1)
	return
}

// InsertModulesAfterCounter returns a count of finished StoreMock.InsertModules invocations
func (mmInsertModules *StoreMock) InsertModulesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertModules.afterInsertModulesCounter)
}

// InsertModulesBeforeCounter returns a count of StoreMock.InsertModules invocations
func (mmInsertModules *StoreMock) InsertModulesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertModules.beforeInsertModulesCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.InsertModules.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertModules *mStoreMockInsertModules) Calls() []*StoreMockInsertModulesParams {
	mmInsertModules.mutex.RLock()

	argCopy := make([]*StoreMockInsertModulesParams, len(mmInsertModules.callArgs))
	copy(argCopy, mmInsertModules.callArgs)

	mmInsertModules.mutex.RUnlock()

	return argCopy
}

// MinimockInsertModulesDone returns true if the count of the InsertModules invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockInsertModulesDone() bool {
	for _, e := range m.InsertModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertModulesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertModulesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertModules != nil && mm_atomic.LoadUint64(&m.afterInsertModulesCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertModulesInspect logs each unmet expectation
func (m *StoreMock) MinimockInsertModulesInspect() {
	for _, e := range m.InsertModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.InsertModules with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertModulesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertModulesCounter) < 1 {
		if m.InsertModulesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.InsertModules")
		} else {
			m.t.Errorf("Expected call to StoreMock.InsertModules with params: %#v", *m.InsertModulesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertModules != nil && mm_atomic.LoadUint64(&m.afterInsertModulesCounter) < 1 {
		m.t.Error("Expected call to StoreMock.InsertModules")
	}
}

type mStoreMockListHeartbeats struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListHeartbeatsExpectation
	expectations       []*StoreMockListHeartbeatsExpectation
}

// StoreMockListHeartbeatsExpectation specifies expectation struct of the Store.ListHeartbeats
type StoreMockListHeartbeatsExpectation struct {
	mock *StoreMock

	results *StoreMockListHeartbeatsResults
	Counter uint64
}

// StoreMockListHeartbeatsResults contains results of the Store.ListHeartbeats
type StoreMockListHeartbeatsResults struct {
	ha1 []payloads.Heartbeat
	err error
}

// Expect sets up expected params for Store.ListHeartbeats
func (mmListHeartbeats *mStoreMockListHeartbeats) Expect() *mStoreMockListHeartbeats {
	if mmListHeartbeats.mock.funcListHeartbeats != nil {
		mmListHeartbeats.mock.t.Fatalf("StoreMock.ListHeartbeats mock is already set by Set")
	}

	if mmListHeartbeats.defaultExpectation == nil {
		mmListHeartbeats.defaultExpectation = &StoreMockListHeartbeatsExpectation{}
	}

	return mmListHeartbeats
}

// Return sets up results that will be returned by Store.ListHeartbeats
func (mmListHeartbeats *mStoreMockListHeartbeats) Return(ha1 []payloads.Heartbeat, err error) *StoreMock {
	if mmListHeartbeats.mock.funcListHeartbeats != nil {
		mmListHeartbeats.mock.t.Fatalf("StoreMock.ListHeartbeats mock is already set by Set")
	}

	if mmListHeartbeats.defaultExpectation == nil {
		mmListHeartbeats.defaultExpectation = &StoreMockListHeartbeatsExpectation{mock: mmListHeartbeats.mock}
	}
	mmListHeartbeats.defaultExpectation.results = &StoreMockListHeartbeatsResults{ha1, err}
	return mmListHeartbeats.mock
}

//Set uses given function f to mock the Store.ListHeartbeats method
func (mmListHeartbeats *mStoreMockListHeartbeats) Set(f func() (ha1 []payloads.Heartbeat, err error)) *StoreMock {
	if mmListHeartbeats.defaultExpectation != nil {
		mmListHeartbeats.mock.t.Fatalf("Default expectation is already set for the Store.ListHeartbeats method")
	}

	if len(mmListHeartbeats.expectations) > 0 {
		mmListHeartbeats.mock.t.Fatalf("Some expectations are already set for the Store.ListHeartbeats method")
	}

	mmListHeartbeats.mock.funcListHeartbeats = f
	return mmListHeartbeats.mock
}

// ListHeartbeats implements Store
func (mmListHeartbeats *StoreMock) ListHeartbeats() (ha1 []payloads.Heartbeat, err error) {
	mm_atomic.AddUint64(&mmListHeartbeats.beforeListHeartbeatsCounter, 1)
	defer mm_atomic.AddUint64(&mmListHeartbeats.afterListHeartbeatsCounter, 1)

	if mmListHeartbeats.ListHeartbeatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListHeartbeats.ListHeartbeatsMock.defaultExpectation.Counter, 1)

		results := mmListHeartbeats.ListHeartbeatsMock.defaultExpectation.results
		if results == nil {
			mmListHeartbeats.t.Fatal("No results are set for the StoreMock.ListHeartbeats")
		}
		return (*results).ha1, (*results).err
	}
	if mmListHeartbeats.funcListHeartbeats != nil {
		return mmListHeartbeats.funcListHeartbeats()
	}
	mmListHeartbeats.t.Fatalf("Unexpected call to StoreMock.ListHeartbeats.")
	return
}

// ListHeartbeatsAfterCounter returns a count of finished StoreMock.ListHeartbeats invocations
func (mmListHeartbeats *StoreMock) ListHeartbeatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHeartbeats.afterListHeartbeatsCounter)
}

// ListHeartbeatsBeforeCounter returns a count of StoreMock.ListHeartbeats invocations
func (mmListHeartbeats *StoreMock) ListHeartbeatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHeartbeats.beforeListHeartbeatsCounter)
}

// MinimockListHeartbeatsDone returns true if the count of the ListHeartbeats invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListHeartbeatsDone() bool {
	for _, e := range m.ListHeartbeatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHeartbeatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHeartbeatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHeartbeats != nil && mm_atomic.LoadUint64(&m.afterListHeartbeatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListHeartbeatsInspect logs each unmet expectation
func (m *StoreMock) MinimockListHeartbeatsInspect() {
	for _, e := range m.ListHeartbeatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StoreMock.ListHeartbeats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHeartbeatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHeartbeatsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListHeartbeats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHeartbeats != nil && mm_atomic.LoadUint64(&m.afterListHeartbeatsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListHeartbeats")
	}
}

type mStoreMockListModuleIDs struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListModuleIDsExpectation
	expectations       []*StoreMockListModuleIDsExpectation
}

// StoreMockListModuleIDsExpectation specifies expectation struct of the Store.ListModuleIDs
type StoreMockListModuleIDsExpectation struct {
	mock *StoreMock

	results *StoreMockListModuleIDsResults
	Counter uint64
}

// StoreMockListModuleIDsResults contains results of the Store.ListModuleIDs
type StoreMockListModuleIDsResults struct {
	ia1 []int64
	err error
}

// Expect sets up expected params for Store.ListModuleIDs
func (mmListModuleIDs *mStoreMockListModuleIDs) Expect() *mStoreMockListModuleIDs {
	if mmListModuleIDs.mock.funcListModuleIDs != nil {
		mmListModuleIDs.mock.t.Fatalf("StoreMock.ListModuleIDs mock is already set by Set")
	}

	if mmListModuleIDs.defaultExpectation == nil {
		mmListModuleIDs.defaultExpectation = &StoreMockListModuleIDsExpectation{}
	}

	return mmListModuleIDs
}

// Return sets up results that will be returned by Store.ListModuleIDs
func (mmListModuleIDs *mStoreMockListModuleIDs) Return(ia1 []int64, err error) *StoreMock {
	if mmListModuleIDs.mock.funcListModuleIDs != nil {
		mmListModuleIDs.mock.t.Fatalf("StoreMock.ListModuleIDs mock is already set by Set")
	}

	if mmListModuleIDs.defaultExpectation == nil {
		mmListModuleIDs.defaultExpectation = &StoreMockListModuleIDsExpectation{mock: mmListModuleIDs.mock}
	}
	mmListModuleIDs.defaultExpectation.results = &StoreMockListModuleIDsResults{ia1, err}
	return mmListModuleIDs.mock
}

//Set uses given function f to mock the Store.ListModuleIDs method
func (mmListModuleIDs *mStoreMockListModuleIDs) Set(f func() (ia1 []int64, err error)) *StoreMock {
	if mmListModuleIDs.defaultExpectation != nil {
		mmListModuleIDs.mock.t.Fatalf("Default expectation is already set for the Store.ListModuleIDs method")
	}

	if len(mmListModuleIDs.expectations) > 0 {
		mmListModuleIDs.mock.t.Fatalf("Some expectations are already set for the Store.ListModuleIDs method")
	}

	mmListModuleIDs.mock.funcListModuleIDs = f
	return mmListModuleIDs.mock
}

// ListModuleIDs implements Store
func (mmListModuleIDs *StoreMock) ListModuleIDs() (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmListModuleIDs.beforeListModuleIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModuleIDs.afterListModuleIDsCounter, 1)

	if mmListModuleIDs.ListModuleIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModuleIDs.ListModuleIDsMock.defaultExpectation.Counter, 1)

		results := mmListModuleIDs.ListModuleIDsMock.defaultExpectation.results
		if results == nil {
			mmListModuleIDs.t.Fatal("No results are set for the StoreMock.ListModuleIDs")
		}
		return (*results).ia1, (*results).err
	}
	if mmListModuleIDs.funcListModuleIDs != nil {
		return mmListModuleIDs.funcListModuleIDs()
	}
	mmListModuleIDs.t.Fatalf("Unexpected call to StoreMock.ListModuleIDs.")
	return
}

// ListModuleIDsAfterCounter returns a count of finished StoreMock.ListModuleIDs invocations
func (mmListModuleIDs *StoreMock) ListModuleIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModuleIDs.afterListModuleIDsCounter)
}

// ListModuleIDsBeforeCounter returns a count of StoreMock.ListModuleIDs invocations
func (mmListModuleIDs *StoreMock) ListModuleIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModuleIDs.beforeListModuleIDsCounter)
}

// MinimockListModuleIDsDone returns true if the count of the ListModuleIDs invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListModuleIDsDone() bool {
	for _, e := range m.ListModuleIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModuleIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModuleIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModuleIDs != nil && mm_atomic.LoadUint64(&m.afterListModuleIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListModuleIDsInspect logs each unmet expectation
func (m *StoreMock) MinimockListModuleIDsInspect() {
	for _, e := range m.ListModuleIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StoreMock.ListModuleIDs")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModuleIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModuleIDsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModuleIDs")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModuleIDs != nil && mm_atomic.LoadUint64(&m.afterListModuleIDsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModuleIDs")
	}
}

type mStoreMockListModules struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListModulesExpectation
	expectations       []*StoreMockListModulesExpectation
}

// StoreMockListModulesExpectation specifies expectation struct of the Store.ListModules
type StoreMockListModulesExpectation struct {
	mock *StoreMock

	results *StoreMockListModulesResults
	Counter uint64
}

// StoreMockListModulesResults contains results of the Store.ListModules
type StoreMockListModulesResults struct {
	sa1 []coordinates.SerialModule
	err error
}

// Expect sets up expected params for Store.ListModules
func (mmListModules *mStoreMockListModules) Expect() *mStoreMockListModules {
	if mmListModules.mock.funcListModules != nil {
		mmListModules.mock.t.Fatalf("StoreMock.ListModules mock is already set by Set")
	}

	if mmListModules.defaultExpectation == nil {
		mmListModules.defaultExpectation = &StoreMockListModulesExpectation{}
	}

	return mmListModules
}

// Return sets up results that will be returned by Store.ListModules
func (mmListModules *mStoreMockListModules) Return(sa1 []coordinates.SerialModule, err error) *StoreMock {
	if mmListModules.mock.funcListModules != nil {
		mmListModules.mock.t.Fatalf("StoreMock.ListModules mock is already set by Set")
	}

	if mmListModules.defaultExpectation == nil {
		mmListModules.defaultExpectation = &StoreMockListModulesExpectation{mock: mmListModules.mock}
	}
	mmListModules.defaultExpectation.results = &StoreMockListModulesResults{sa1, err}
	return mmListModules.mock
}

//Set uses given function f to mock the Store.ListModules method
func (mmListModules *mStoreMockListModules) Set(f func() (sa1 []coordinates.SerialModule, err error)) *StoreMock {
	if mmListModules.defaultExpectation != nil {
		mmListModules.mock.t.Fatalf("Default expectation is already set for the Store.ListModules method")
	}

	if len(mmListModules.expectations) > 0 {
		mmListModules.mock.t.Fatalf("Some expectations are already set for the Store.ListModules method")
	}

	mmListModules.mock.funcListModules = f
	return mmListModules.mock
}

// ListModules implements Store
func (mmListModules *StoreMock) ListModules() (sa1 []coordinates.SerialModule, err error) {
	mm_atomic.AddUint64(&mmListModules.beforeListModulesCounter, 1)
	defer mm_atomic.AddUint64(&mmListModules.afterListModulesCounter, 1)

	if mmListModules.ListModulesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModules.ListModulesMock.defaultExpectation.Counter, 1)

		results := mmListModules.ListModulesMock.defaultExpectation.results
		if results == nil {
			mmListModules.t.Fatal("No results are set for the StoreMock.ListModules")
		}
		return (*results).sa1, (*results).err
	}
	if mmListModules.funcListModules != nil {
		return mmListModules.funcListModules()
	}
	mmListModules.t.Fatalf("Unexpected call to StoreMock.ListModules.")
	return
}

// ListModulesAfterCounter returns a count of finished StoreMock.ListModules invocations
func (mmListModules *StoreMock) ListModulesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModules.afterListModulesCounter)
}

// ListModulesBeforeCounter returns a count of StoreMock.ListModules invocations
func (mmListModules *StoreMock) ListModulesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModules.beforeListModulesCounter)
}

// MinimockListModulesDone returns true if the count of the ListModules invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListModulesDone() bool {
	for _, e := range m.ListModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModules != nil && mm_atomic.LoadUint64(&m.afterListModulesCounter) < 1 {
		return false
	}
	return true
}

// MinimockListModulesInspect logs each unmet expectation
func (m *StoreMock) MinimockListModulesInspect() {
	for _, e := range m.ListModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StoreMock.ListModules")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModules")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModules != nil && mm_atomic.LoadUint64(&m.afterListModulesCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModules")
	}
}

type mStoreMockListModulesByIDs struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListModulesByIDsExpectation
	expectations       []*StoreMockListModulesByIDsExpectation

	callArgs []*StoreMockListModulesByIDsParams
	mutex    sync.RWMutex
}

// StoreMockListModulesByIDsExpectation specifies expectation struct of the Store.ListModulesByIDs
type StoreMockListModulesByIDsExpectation struct {
	mock    *StoreMock
	params  *StoreMockListModulesByIDsParams
	results *StoreMockListModulesByIDsResults
	Counter uint64
}

// StoreMockListModulesByIDsParams contains parameters of the Store.ListModulesByIDs
type StoreMockListModulesByIDsParams struct {
	ids []int64
}

// StoreMockListModulesByIDsResults contains results of the Store.ListModulesByIDs
type StoreMockListModulesByIDsResults struct {
	sa1 []coordinates.SerialModule
	err error
}

// Expect sets up expected params for Store.ListModulesByIDs
func (mmListModulesByIDs *mStoreMockListModulesByIDs) Expect(ids []int64) *mStoreMockListModulesByIDs {
	if mmListModulesByIDs.mock.funcListModulesByIDs != nil {
		mmListModulesByIDs.mock.t.Fatalf("StoreMock.ListModulesByIDs mock is already set by Set")
	}

	if mmListModulesByIDs.defaultExpectation == nil {
		mmListModulesByIDs.defaultExpectation = &StoreMockListModulesByIDsExpectation{}
	}

	mmListModulesByIDs.defaultExpectation.params = &StoreMockListModulesByIDsParams{ids}
	for _, e := range mmListModulesByIDs.expectations {
		if minimock.Equal(e.params, mmListModulesByIDs.defaultExpectation.params) {
			mmListModulesByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModulesByIDs.defaultExpectation.params)
		}
	}

	return mmListModulesByIDs
}

// Return sets up results that will be returned by Store.ListModulesByIDs
func (mmListModulesByIDs *mStoreMockListModulesByIDs) Return(sa1 []coordinates.SerialModule, err error) *StoreMock {
	if mmListModulesByIDs.mock.funcListModulesByIDs != nil {
		mmListModulesByIDs.mock.t.Fatalf("StoreMock.ListModulesByIDs mock is already set by Set")
	}

	if mmListModulesByIDs.defaultExpectation == nil {
		mmListModulesByIDs.defaultExpectation = &StoreMockListModulesByIDsExpectation{mock: mmListModulesByIDs.mock}
	}
	mmListModulesByIDs.defaultExpectation.results = &StoreMockListModulesByIDsResults{sa1, err}
	return mmListModulesByIDs.mock
}

//Set uses given function f to mock the Store.ListModulesByIDs method
func (mmListModulesByIDs *mStoreMockListModulesByIDs) Set(f func(ids []int64) (sa1 []coordinates.SerialModule, err error)) *StoreMock {
	if mmListModulesByIDs.defaultExpectation != nil {
		mmListModulesByIDs.mock.t.Fatalf("Default expectation is already set for the Store.ListModulesByIDs method")
	}

	if len(mmListModulesByIDs.expectations) > 0 {
		mmListModulesByIDs.mock.t.Fatalf("Some expectations are already set for the Store.ListModulesByIDs method")
	}

	mmListModulesByIDs.mock.funcListModulesByIDs = f
	return mmListModulesByIDs.mock
}

// When sets expectation for the Store.ListModulesByIDs which will trigger the result defined by the following
// Then helper
func (mmListModulesByIDs *mStoreMockListModulesByIDs) When(ids []int64) *StoreMockListModulesByIDsExpectation {
	if mmListModulesByIDs.mock.funcListModulesByIDs != nil {
		mmListModulesByIDs.mock.t.Fatalf("StoreMock.ListModulesByIDs mock is already set by Set")
	}

	expectation := &StoreMockListModulesByIDsExpectation{
		mock:   mmListModulesByIDs.mock,
		params: &StoreMockListModulesByIDsParams{ids},
	}
	mmListModulesByIDs.expectations = append(mmListModulesByIDs.expectations, expectation)
	return expectation
}

// Then sets up Store.ListModulesByIDs return parameters for the expectation previously defined by the When method
func (e *StoreMockListModulesByIDsExpectation) Then(sa1 []coordinates.SerialModule, err error) *StoreMock {
	e.results = &StoreMockListModulesByIDsResults{sa1, err}
	return e.mock
}

// ListModulesByIDs implements Store
func (mmListModulesByIDs *StoreMock) ListModulesByIDs(ids []int64) (sa1 []coordinates.SerialModule, err error) {
	mm_atomic.AddUint64(&mmListModulesByIDs.beforeListModulesByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModulesByIDs.afterListModulesByIDsCounter, 1)

	params := &StoreMockListModulesByIDsParams{ids}

	// Record call args
	mmListModulesByIDs.ListModulesByIDsMock.mutex.Lock()
	mmListModulesByIDs.ListModulesByIDsMock.callArgs = append(mmListModulesByIDs.ListModulesByIDsMock.callArgs, params)
	mmListModulesByIDs.ListModulesByIDsMock.mutex.Unlock()

	for _, e := range mmListModulesByIDs.ListModulesByIDsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListModulesByIDs.ListModulesByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModulesByIDs.ListModulesByIDsMock.defaultExpectation.Counter, 1)
		want := mmListModulesByIDs.ListModulesByIDsMock.defaultExpectation.params
		got := StoreMockListModulesByIDsParams{ids}
		if want != nil && !minimock.Equal(*want, got) {
			mmListModulesByIDs.t.Errorf("StoreMock.ListModulesByIDs got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmListModulesByIDs.ListModulesByIDsMock.defaultExpectation.results
		if results == nil {
			mmListModulesByIDs.t.Fatal("No results are set for the StoreMock.ListModulesByIDs")
		}
		return (*results).sa1, (*results).err
	}
	if mmListModulesByIDs.funcListModulesByIDs != nil {
		return mmListModulesByIDs.funcListModulesByIDs(ids)
	}
	mmListModulesByIDs.t.Fatalf("Unexpected call to StoreMock.ListModulesByIDs. %v", ids)
	return
}

// ListModulesByIDsAfterCounter returns a count of finished StoreMock.ListModulesByIDs invocations
func (mmListModulesByIDs *StoreMock) ListModulesByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModulesByIDs.afterListModulesByIDsCounter)
}

// ListModulesByIDsBeforeCounter returns a count of StoreMock.ListModulesByIDs invocations
func (mmListModulesByIDs *StoreMock) ListModulesByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModulesByIDs.beforeListModulesByIDsCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.ListModulesByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModulesByIDs *mStoreMockListModulesByIDs) Calls() []*StoreMockListModulesByIDsParams {
	mmListModulesByIDs.mutex.RLock()

	argCopy := make([]*StoreMockListModulesByIDsParams, len(mmListModulesByIDs.callArgs))
	copy(argCopy, mmListModulesByIDs.callArgs)

	mmListModulesByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockListModulesByIDsDone returns true if the count of the ListModulesByIDs invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListModulesByIDsDone() bool {
	for _, e := range m.ListModulesByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesByIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModulesByIDs != nil && mm_atomic.LoadUint64(&m.afterListModulesByIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListModulesByIDsInspect logs each unmet expectation
func (m *StoreMock) MinimockListModulesByIDsInspect() {
	for _, e := range m.ListModulesByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.ListModulesByIDs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesByIDsCounter) < 1 {
		if m.ListModulesByIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.ListModulesByIDs")
		} else {
			m.t.Errorf("Expected call to StoreMock.ListModulesByIDs with params: %#v", *m.ListModulesByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModulesByIDs != nil && mm_atomic.LoadUint64(&m.afterListModulesByIDsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModulesByIDs")
	}
}

type mStoreMockListModulesBySource struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListModulesBySourceExpectation
	expectations       []*StoreMockListModulesBySourceExpectation

	callArgs []*StoreMockListModulesBySourceParams
	mutex    sync.RWMutex
}

// StoreMockListModulesBySourceExpectation specifies expectation struct of the Store.ListModulesBySource
type StoreMockListModulesBySourceExpectation struct {
	mock    *StoreMock
	params  *StoreMockListModulesBySourceParams
	results *StoreMockListModulesBySourceResults
	Counter uint64
}

// StoreMockListModulesBySourceParams contains parameters of the Store.ListModulesBySource
type StoreMockListModulesBySourceParams struct {
	source string
}

// StoreMockListModulesBySourceResults contains results of the Store.ListModulesBySource
type StoreMockListModulesBySourceResults struct {
	sa1 []coordinates.SerialModule
	err error
}

// Expect sets up expected params for Store.ListModulesBySource
func (mmListModulesBySource *mStoreMockListModulesBySource) Expect(source string) *mStoreMockListModulesBySource {
	if mmListModulesBySource.mock.funcListModulesBySource != nil {
		mmListModulesBySource.mock.t.Fatalf("StoreMock.ListModulesBySource mock is already set by Set")
	}

	if mmListModulesBySource.defaultExpectation == nil {
		mmListModulesBySource.defaultExpectation = &StoreMockListModulesBySourceExpectation{}
	}

	mmListModulesBySource.defaultExpectation.params = &StoreMockListModulesBySourceParams{source}
	for _, e := range mmListModulesBySource.expectations {
		if minimock.Equal(e.params, mmListModulesBySource.defaultExpectation.params) {
			mmListModulesBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModulesBySource.defaultExpectation.params)
		}
	}

	return mmListModulesBySource
}

// Return sets up results that will be returned by Store.ListModulesBySource
func (mmListModulesBySource *mStoreMockListModulesBySource) Return(sa1 []coordinates.SerialModule, err error) *StoreMock {
	if mmListModulesBySource.mock.funcListModulesBySource != nil {
		mmListModulesBySource.mock.t.Fatalf("StoreMock.ListModulesBySource mock is already set by Set")
	}

	if mmListModulesBySource.defaultExpectation == nil {
		mmListModulesBySource.defaultExpectation = &StoreMockListModulesBySourceExpectation{mock: mmListModulesBySource.mock}
	}
	mmListModulesBySource.defaultExpectation.results = &StoreMockListModulesBySourceResults{sa1, err}
	return mmListModulesBySource.mock
}

//Set uses given function f to mock the Store.ListModulesBySource method
func (mmListModulesBySource *mStoreMockListModulesBySource) Set(f func(source string) (sa1 []coordinates.SerialModule, err error)) *StoreMock {
	if mmListModulesBySource.defaultExpectation != nil {
		mmListModulesBySource.mock.t.Fatalf("Default expectation is already set for the Store.ListModulesBySource method")
	}

	if len(mmListModulesBySource.expectations) > 0 {
		mmListModulesBySource.mock.t.Fatalf("Some expectations are already set for the Store.ListModulesBySource method")
	}

	mmListModulesBySource.mock.funcListModulesBySource = f
	return mmListModulesBySource.mock
}

// When sets expectation for the Store.ListModulesBySource which will trigger the result defined by the following
// Then helper
func (mmListModulesBySource *mStoreMockListModulesBySource) When(source string) *StoreMockListModulesBySourceExpectation {
	if mmListModulesBySource.mock.funcListModulesBySource != nil {
		mmListModulesBySource.mock.t.Fatalf("StoreMock.ListModulesBySource mock is already set by Set")
	}

	expectation := &StoreMockListModulesBySourceExpectation{
		mock:   mmListModulesBySource.mock,
		params: &StoreMockListModulesBySourceParams{source},
	}
	mmListModulesBySource.expectations = append(mmListModulesBySource.expectations, expectation)
	return expectation
}

// Then sets up Store.ListModulesBySource return parameters for the expectation previously defined by the When method
func (e *StoreMockListModulesBySourceExpectation) Then(sa1 []coordinates.SerialModule, err error) *StoreMock {
	e.results = &StoreMockListModulesBySourceResults{sa1, err}
	return e.mock
}

// ListModulesBySource implements Store
func (mmListModulesBySource *StoreMock) ListModulesBySource(source string) (sa1 []coordinates.SerialModule, err error) {
	mm_atomic.AddUint64(&mmListModulesBySource.beforeListModulesBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmListModulesBySource.afterListModulesBySourceCounter, 1)

	params := &StoreMockListModulesBySourceParams{source}

	// Record call args
	mmListModulesBySource.ListModulesBySourceMock.mutex.Lock()
	mmListModulesBySource.ListModulesBySourceMock.callArgs = append(mmListModulesBySource.ListModulesBySourceMock.callArgs, params)
	mmListModulesBySource.ListModulesBySourceMock.mutex.Unlock()

	for _, e := range mmListModulesBySource.ListModulesBySourceMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListModulesBySource.ListModulesBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModulesBySource.ListModulesBySourceMock.defaultExpectation.Counter, 1)
		want := mmListModulesBySource.ListModulesBySourceMock.defaultExpectation.params
		got := StoreMockListModulesBySourceParams{source}
		if want != nil && !minimock.Equal(*want, got) {
			mmListModulesBySource.t.Errorf("StoreMock.ListModulesBySource got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmListModulesBySource.ListModulesBySourceMock.defaultExpectation.results
		if results == nil {
			mmListModulesBySource.t.Fatal("No results are set for the StoreMock.ListModulesBySource")
		}
		return (*results).sa1, (*results).err
	}
	if mmListModulesBySource.funcListModulesBySource != nil {
		return mmListModulesBySource.funcListModulesBySource(source)
	}
	mmListModulesBySource.t.Fatalf("Unexpected call to StoreMock.ListModulesBySource. %v", source)
	return
}

// ListModulesBySourceAfterCounter returns a count of finished StoreMock.ListModulesBySource invocations
func (mmListModulesBySource *StoreMock) ListModulesBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModulesBySource.afterListModulesBySourceCounter)
}

// ListModulesBySourceBeforeCounter returns a count of StoreMock.ListModulesBySource invocations
func (mmListModulesBySource *StoreMock) ListModulesBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModulesBySource.beforeListModulesBySourceCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.ListModulesBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModulesBySource *mStoreMockListModulesBySource) Calls() []*StoreMockListModulesBySourceParams {
	mmListModulesBySource.mutex.RLock()

	argCopy := make([]*StoreMockListModulesBySourceParams, len(mmListModulesBySource.callArgs))
	copy(argCopy, mmListModulesBySource.callArgs)

	mmListModulesBySource.mutex.RUnlock()

	return argCopy
}

// MinimockListModulesBySourceDone returns true if the count of the ListModulesBySource invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListModulesBySourceDone() bool {
	for _, e := range m.ListModulesBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesBySourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesBySourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModulesBySource != nil && mm_atomic.LoadUint64(&m.afterListModulesBySourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockListModulesBySourceInspect logs each unmet expectation
func (m *StoreMock) MinimockListModulesBySourceInspect() {
	for _, e := range m.ListModulesBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.ListModulesBySource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListModulesBySourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListModulesBySourceCounter) < 1 {
		if m.ListModulesBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.ListModulesBySource")
		} else {
			m.t.Errorf("Expected call to StoreMock.ListModulesBySource with params: %#v", *m.ListModulesBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModulesBySource != nil && mm_atomic.LoadUint64(&m.afterListModulesBySourceCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListModulesBySource")
	}
}

type mStoreMockListStartConfigs struct {
	mock               *StoreMock
	defaultExpectation *StoreMockListStartConfigsExpectation
	expectations       []*StoreMockListStartConfigsExpectation
}

// StoreMockListStartConfigsExpectation specifies expectation struct of the Store.ListStartConfigs
type StoreMockListStartConfigsExpectation struct {
	mock *StoreMock

	results *StoreMockListStartConfigsResults
	Counter uint64
}

// StoreMockListStartConfigsResults contains results of the Store.ListStartConfigs
type StoreMockListStartConfigsResults struct {
	ca1 []payloads.Configuration
	err error
}

// Expect sets up expected params for Store.ListStartConfigs
func (mmListStartConfigs *mStoreMockListStartConfigs) Expect() *mStoreMockListStartConfigs {
	if mmListStartConfigs.mock.funcListStartConfigs != nil {
		mmListStartConfigs.mock.t.Fatalf("StoreMock.ListStartConfigs mock is already set by Set")
	}

	if mmListStartConfigs.defaultExpectation == nil {
		mmListStartConfigs.defaultExpectation = &StoreMockListStartConfigsExpectation{}
	}

	return mmListStartConfigs
}

// Return sets up results that will be returned by Store.ListStartConfigs
func (mmListStartConfigs *mStoreMockListStartConfigs) Return(ca1 []payloads.Configuration, err error) *StoreMock {
	if mmListStartConfigs.mock.funcListStartConfigs != nil {
		mmListStartConfigs.mock.t.Fatalf("StoreMock.ListStartConfigs mock is already set by Set")
	}

	if mmListStartConfigs.defaultExpectation == nil {
		mmListStartConfigs.defaultExpectation = &StoreMockListStartConfigsExpectation{mock: mmListStartConfigs.mock}
	}
	mmListStartConfigs.defaultExpectation.results = &StoreMockListStartConfigsResults{ca1, err}
	return mmListStartConfigs.mock
}

//Set uses given function f to mock the Store.ListStartConfigs method
func (mmListStartConfigs *mStoreMockListStartConfigs) Set(f func() (ca1 []payloads.Configuration, err error)) *StoreMock {
	if mmListStartConfigs.defaultExpectation != nil {
		mmListStartConfigs.mock.t.Fatalf("Default expectation is already set for the Store.ListStartConfigs method")
	}

	if len(mmListStartConfigs.expectations) > 0 {
		mmListStartConfigs.mock.t.Fatalf("Some expectations are already set for the Store.ListStartConfigs method")
	}

	mmListStartConfigs.mock.funcListStartConfigs = f
	return mmListStartConfigs.mock
}

// ListStartConfigs implements Store
func (mmListStartConfigs *StoreMock) ListStartConfigs() (ca1 []payloads.Configuration, err error) {
	mm_atomic.AddUint64(&mmListStartConfigs.beforeListStartConfigsCounter, 1)
	defer mm_atomic.AddUint64(&mmListStartConfigs.afterListStartConfigsCounter, 1)

	if mmListStartConfigs.ListStartConfigsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListStartConfigs.ListStartConfigsMock.defaultExpectation.Counter, 1)

		results := mmListStartConfigs.ListStartConfigsMock.defaultExpectation.results
		if results == nil {
			mmListStartConfigs.t.Fatal("No results are set for the StoreMock.ListStartConfigs")
		}
		return (*results).ca1, (*results).err
	}
	if mmListStartConfigs.funcListStartConfigs != nil {
		return mmListStartConfigs.funcListStartConfigs()
	}
	mmListStartConfigs.t.Fatalf("Unexpected call to StoreMock.ListStartConfigs.")
	return
}

// ListStartConfigsAfterCounter returns a count of finished StoreMock.ListStartConfigs invocations
func (mmListStartConfigs *StoreMock) ListStartConfigsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStartConfigs.afterListStartConfigsCounter)
}

// ListStartConfigsBeforeCounter returns a count of StoreMock.ListStartConfigs invocations
func (mmListStartConfigs *StoreMock) ListStartConfigsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStartConfigs.beforeListStartConfigsCounter)
}

// MinimockListStartConfigsDone returns true if the count of the ListStartConfigs invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockListStartConfigsDone() bool {
	for _, e := range m.ListStartConfigsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListStartConfigsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListStartConfigsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStartConfigs != nil && mm_atomic.LoadUint64(&m.afterListStartConfigsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListStartConfigsInspect logs each unmet expectation
func (m *StoreMock) MinimockListStartConfigsInspect() {
	for _, e := range m.ListStartConfigsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StoreMock.ListStartConfigs")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListStartConfigsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListStartConfigsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListStartConfigs")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStartConfigs != nil && mm_atomic.LoadUint64(&m.afterListStartConfigsCounter) < 1 {
		m.t.Error("Expected call to StoreMock.ListStartConfigs")
	}
}

type mStoreMockPurgeProxy struct {
	mock               *StoreMock
	defaultExpectation *StoreMockPurgeProxyExpectation
	expectations       []*StoreMockPurgeProxyExpectation

	callArgs []*StoreMockPurgeProxyParams
	mutex    sync.RWMutex
}

// StoreMockPurgeProxyExpectation specifies expectation struct of the Store.PurgeProxy
type StoreMockPurgeProxyExpectation struct {
	mock    *StoreMock
	params  *StoreMockPurgeProxyParams
	results *StoreMockPurgeProxyResults
	Counter uint64
}

// StoreMockPurgeProxyParams contains parameters of the Store.PurgeProxy
type StoreMockPurgeProxyParams struct {
	instance netservice.Instance
}

// StoreMockPurgeProxyResults contains results of the Store.PurgeProxy
type StoreMockPurgeProxyResults struct {
	err error
}

// Expect sets up expected params for Store.PurgeProxy
func (mmPurgeProxy *mStoreMockPurgeProxy) Expect(instance netservice.Instance) *mStoreMockPurgeProxy {
	if mmPurgeProxy.mock.funcPurgeProxy != nil {
		mmPurgeProxy.mock.t.Fatalf("StoreMock.PurgeProxy mock is already set by Set")
	}

	if mmPurgeProxy.defaultExpectation == nil {
		mmPurgeProxy.defaultExpectation = &StoreMockPurgeProxyExpectation{}
	}

	mmPurgeProxy.defaultExpectation.params = &StoreMockPurgeProxyParams{instance}
	for _, e := range mmPurgeProxy.expectations {
		if minimock.Equal(e.params, mmPurgeProxy.defaultExpectation.params) {
			mmPurgeProxy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurgeProxy.defaultExpectation.params)
		}
	}

	return mmPurgeProxy
}

// Return sets up results that will be returned by Store.PurgeProxy
func (mmPurgeProxy *mStoreMockPurgeProxy) Return(err error) *StoreMock {
	if mmPurgeProxy.mock.funcPurgeProxy != nil {
		mmPurgeProxy.mock.t.Fatalf("StoreMock.PurgeProxy mock is already set by Set")
	}

	if mmPurgeProxy.defaultExpectation == nil {
		mmPurgeProxy.defaultExpectation = &StoreMockPurgeProxyExpectation{mock: mmPurgeProxy.mock}
	}
	mmPurgeProxy.defaultExpectation.results = &StoreMockPurgeProxyResults{err}
	return mmPurgeProxy.mock
}

//Set uses given function f to mock the Store.PurgeProxy method
func (mmPurgeProxy *mStoreMockPurgeProxy) Set(f func(instance netservice.Instance) (err error)) *StoreMock {
	if mmPurgeProxy.defaultExpectation != nil {
		mmPurgeProxy.mock.t.Fatalf("Default expectation is already set for the Store.PurgeProxy method")
	}

	if len(mmPurgeProxy.expectations) > 0 {
		mmPurgeProxy.mock.t.Fatalf("Some expectations are already set for the Store.PurgeProxy method")
	}

	mmPurgeProxy.mock.funcPurgeProxy = f
	return mmPurgeProxy.mock
}

// When sets expectation for the Store.PurgeProxy which will trigger the result defined by the following
// Then helper
func (mmPurgeProxy *mStoreMockPurgeProxy) When(instance netservice.Instance) *StoreMockPurgeProxyExpectation {
	if mmPurgeProxy.mock.funcPurgeProxy != nil {
		mmPurgeProxy.mock.t.Fatalf("StoreMock.PurgeProxy mock is already set by Set")
	}

	expectation := &StoreMockPurgeProxyExpectation{
		mock:   mmPurgeProxy.mock,
		params: &StoreMockPurgeProxyParams{instance},
	}
	mmPurgeProxy.expectations = append(mmPurgeProxy.expectations, expectation)
	return expectation
}

// Then sets up Store.PurgeProxy return parameters for the expectation previously defined by the When method
func (e *StoreMockPurgeProxyExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockPurgeProxyResults{err}
	return e.mock
}

// PurgeProxy implements Store
func (mmPurgeProxy *StoreMock) PurgeProxy(instance netservice.Instance) (err error) {
	mm_atomic.AddUint64(&mmPurgeProxy.beforePurgeProxyCounter, 1)
	defer mm_atomic.AddUint64(&mmPurgeProxy.afterPurgeProxyCounter, 1)

	params := &StoreMockPurgeProxyParams{instance}

	// Record call args
	mmPurgeProxy.PurgeProxyMock.mutex.Lock()
	mmPurgeProxy.PurgeProxyMock.callArgs = append(mmPurgeProxy.PurgeProxyMock.callArgs, params)
	mmPurgeProxy.PurgeProxyMock.mutex.Unlock()

	for _, e := range mmPurgeProxy.PurgeProxyMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurgeProxy.PurgeProxyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurgeProxy.PurgeProxyMock.defaultExpectation.Counter, 1)
		want := mmPurgeProxy.PurgeProxyMock.defaultExpectation.params
		got := StoreMockPurgeProxyParams{instance}
		if want != nil && !minimock.Equal(*want, got) {
			mmPurgeProxy.t.Errorf("StoreMock.PurgeProxy got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmPurgeProxy.PurgeProxyMock.defaultExpectation.results
		if results == nil {
			mmPurgeProxy.t.Fatal("No results are set for the StoreMock.PurgeProxy")
		}
		return (*results).err
	}
	if mmPurgeProxy.funcPurgeProxy != nil {
		return mmPurgeProxy.funcPurgeProxy(instance)
	}
	mmPurgeProxy.t.Fatalf("Unexpected call to StoreMock.PurgeProxy. %v", instance)
	return
}

// PurgeProxyAfterCounter returns a count of finished StoreMock.PurgeProxy invocations
func (mmPurgeProxy *StoreMock) PurgeProxyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgeProxy.afterPurgeProxyCounter)
}

// PurgeProxyBeforeCounter returns a count of StoreMock.PurgeProxy invocations
func (mmPurgeProxy *StoreMock) PurgeProxyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgeProxy.beforePurgeProxyCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.PurgeProxy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurgeProxy *mStoreMockPurgeProxy) Calls() []*StoreMockPurgeProxyParams {
	mmPurgeProxy.mutex.RLock()

	argCopy := make([]*StoreMockPurgeProxyParams, len(mmPurgeProxy.callArgs))
	copy(argCopy, mmPurgeProxy.callArgs)

	mmPurgeProxy.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeProxyDone returns true if the count of the PurgeProxy invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockPurgeProxyDone() bool {
	for _, e := range m.PurgeProxyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeProxyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurgeProxyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurgeProxy != nil && mm_atomic.LoadUint64(&m.afterPurgeProxyCounter) < 1 {
		return false
	}
	return true
}

// MinimockPurgeProxyInspect logs each unmet expectation
func (m *StoreMock) MinimockPurgeProxyInspect() {
	for _, e := range m.PurgeProxyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.PurgeProxy with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeProxyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPurgeProxyCounter) < 1 {
		if m.PurgeProxyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.PurgeProxy")
		} else {
			m.t.Errorf("Expected call to StoreMock.PurgeProxy with params: %#v", *m.PurgeProxyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurgeProxy != nil && mm_atomic.LoadUint64(&m.afterPurgeProxyCounter) < 1 {
		m.t.Error("Expected call to StoreMock.PurgeProxy")
	}
}

type mStoreMockSetHeartbeat struct {
	mock               *StoreMock
	defaultExpectation *StoreMockSetHeartbeatExpectation
	expectations       []*StoreMockSetHeartbeatExpectation

	callArgs []*StoreMockSetHeartbeatParams
	mutex    sync.RWMutex
}

// StoreMockSetHeartbeatExpectation specifies expectation struct of the Store.SetHeartbeat
type StoreMockSetHeartbeatExpectation struct {
	mock    *StoreMock
	params  *StoreMockSetHeartbeatParams
	results *StoreMockSetHeartbeatResults
	Counter uint64
}

// StoreMockSetHeartbeatParams contains parameters of the Store.SetHeartbeat
type StoreMockSetHeartbeatParams struct {
	h1 payloads.Heartbeat
}

// StoreMockSetHeartbeatResults contains results of the Store.SetHeartbeat
type StoreMockSetHeartbeatResults struct {
	err error
}

// Expect sets up expected params for Store.SetHeartbeat
func (mmSetHeartbeat *mStoreMockSetHeartbeat) Expect(h1 payloads.Heartbeat) *mStoreMockSetHeartbeat {
	if mmSetHeartbeat.mock.funcSetHeartbeat != nil {
		mmSetHeartbeat.mock.t.Fatalf("StoreMock.SetHeartbeat mock is already set by Set")
	}

	if mmSetHeartbeat.defaultExpectation == nil {
		mmSetHeartbeat.defaultExpectation = &StoreMockSetHeartbeatExpectation{}
	}

	mmSetHeartbeat.defaultExpectation.params = &StoreMockSetHeartbeatParams{h1}
	for _, e := range mmSetHeartbeat.expectations {
		if minimock.Equal(e.params, mmSetHeartbeat.defaultExpectation.params) {
			mmSetHeartbeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetHeartbeat.defaultExpectation.params)
		}
	}

	return mmSetHeartbeat
}

// Return sets up results that will be returned by Store.SetHeartbeat
func (mmSetHeartbeat *mStoreMockSetHeartbeat) Return(err error) *StoreMock {
	if mmSetHeartbeat.mock.funcSetHeartbeat != nil {
		mmSetHeartbeat.mock.t.Fatalf("StoreMock.SetHeartbeat mock is already set by Set")
	}

	if mmSetHeartbeat.defaultExpectation == nil {
		mmSetHeartbeat.defaultExpectation = &StoreMockSetHeartbeatExpectation{mock: mmSetHeartbeat.mock}
	}
	mmSetHeartbeat.defaultExpectation.results = &StoreMockSetHeartbeatResults{err}
	return mmSetHeartbeat.mock
}

//Set uses given function f to mock the Store.SetHeartbeat method
func (mmSetHeartbeat *mStoreMockSetHeartbeat) Set(f func(h1 payloads.Heartbeat) (err error)) *StoreMock {
	if mmSetHeartbeat.defaultExpectation != nil {
		mmSetHeartbeat.mock.t.Fatalf("Default expectation is already set for the Store.SetHeartbeat method")
	}

	if len(mmSetHeartbeat.expectations) > 0 {
		mmSetHeartbeat.mock.t.Fatalf("Some expectations are already set for the Store.SetHeartbeat method")
	}

	mmSetHeartbeat.mock.funcSetHeartbeat = f
	return mmSetHeartbeat.mock
}

// When sets expectation for the Store.SetHeartbeat which will trigger the result defined by the following
// Then helper
func (mmSetHeartbeat *mStoreMockSetHeartbeat) When(h1 payloads.Heartbeat) *StoreMockSetHeartbeatExpectation {
	if mmSetHeartbeat.mock.funcSetHeartbeat != nil {
		mmSetHeartbeat.mock.t.Fatalf("StoreMock.SetHeartbeat mock is already set by Set")
	}

	expectation := &StoreMockSetHeartbeatExpectation{
		mock:   mmSetHeartbeat.mock,
		params: &StoreMockSetHeartbeatParams{h1},
	}
	mmSetHeartbeat.expectations = append(mmSetHeartbeat.expectations, expectation)
	return expectation
}

// Then sets up Store.SetHeartbeat return parameters for the expectation previously defined by the When method
func (e *StoreMockSetHeartbeatExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockSetHeartbeatResults{err}
	return e.mock
}

// SetHeartbeat implements Store
func (mmSetHeartbeat *StoreMock) SetHeartbeat(h1 payloads.Heartbeat) (err error) {
	mm_atomic.AddUint64(&mmSetHeartbeat.beforeSetHeartbeatCounter, 1)
	defer mm_atomic.AddUint64(&mmSetHeartbeat.afterSetHeartbeatCounter, 1)

	params := &StoreMockSetHeartbeatParams{h1}

	// Record call args
	mmSetHeartbeat.SetHeartbeatMock.mutex.Lock()
	mmSetHeartbeat.SetHeartbeatMock.callArgs = append(mmSetHeartbeat.SetHeartbeatMock.callArgs, params)
	mmSetHeartbeat.SetHeartbeatMock.mutex.Unlock()

	for _, e := range mmSetHeartbeat.SetHeartbeatMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetHeartbeat.SetHeartbeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetHeartbeat.SetHeartbeatMock.defaultExpectation.Counter, 1)
		want := mmSetHeartbeat.SetHeartbeatMock.defaultExpectation.params
		got := StoreMockSetHeartbeatParams{h1}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetHeartbeat.t.Errorf("StoreMock.SetHeartbeat got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSetHeartbeat.SetHeartbeatMock.defaultExpectation.results
		if results == nil {
			mmSetHeartbeat.t.Fatal("No results are set for the StoreMock.SetHeartbeat")
		}
		return (*results).err
	}
	if mmSetHeartbeat.funcSetHeartbeat != nil {
		return mmSetHeartbeat.funcSetHeartbeat(h1)
	}
	mmSetHeartbeat.t.Fatalf("Unexpected call to StoreMock.SetHeartbeat. %v", h1)
	return
}

// SetHeartbeatAfterCounter returns a count of finished StoreMock.SetHeartbeat invocations
func (mmSetHeartbeat *StoreMock) SetHeartbeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeartbeat.afterSetHeartbeatCounter)
}

// SetHeartbeatBeforeCounter returns a count of StoreMock.SetHeartbeat invocations
func (mmSetHeartbeat *StoreMock) SetHeartbeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeartbeat.beforeSetHeartbeatCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.SetHeartbeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetHeartbeat *mStoreMockSetHeartbeat) Calls() []*StoreMockSetHeartbeatParams {
	mmSetHeartbeat.mutex.RLock()

	argCopy := make([]*StoreMockSetHeartbeatParams, len(mmSetHeartbeat.callArgs))
	copy(argCopy, mmSetHeartbeat.callArgs)

	mmSetHeartbeat.mutex.RUnlock()

	return argCopy
}

// MinimockSetHeartbeatDone returns true if the count of the SetHeartbeat invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockSetHeartbeatDone() bool {
	for _, e := range m.SetHeartbeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeartbeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeartbeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeartbeat != nil && mm_atomic.LoadUint64(&m.afterSetHeartbeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetHeartbeatInspect logs each unmet expectation
func (m *StoreMock) MinimockSetHeartbeatInspect() {
	for _, e := range m.SetHeartbeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.SetHeartbeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeartbeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeartbeatCounter) < 1 {
		if m.SetHeartbeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.SetHeartbeat")
		} else {
			m.t.Errorf("Expected call to StoreMock.SetHeartbeat with params: %#v", *m.SetHeartbeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeartbeat != nil && mm_atomic.LoadUint64(&m.afterSetHeartbeatCounter) < 1 {
		m.t.Error("Expected call to StoreMock.SetHeartbeat")
	}
}

type mStoreMockSetStartConfig struct {
	mock               *StoreMock
	defaultExpectation *StoreMockSetStartConfigExpectation
	expectations       []*StoreMockSetStartConfigExpectation

	callArgs []*StoreMockSetStartConfigParams
	mutex    sync.RWMutex
}

// StoreMockSetStartConfigExpectation specifies expectation struct of the Store.SetStartConfig
type StoreMockSetStartConfigExpectation struct {
	mock    *StoreMock
	params  *StoreMockSetStartConfigParams
	results *StoreMockSetStartConfigResults
	Counter uint64
}

// StoreMockSetStartConfigParams contains parameters of the Store.SetStartConfig
type StoreMockSetStartConfigParams struct {
	c1 payloads.Configuration
}

// StoreMockSetStartConfigResults contains results of the Store.SetStartConfig
type StoreMockSetStartConfigResults struct {
	err error
}

// Expect sets up expected params for Store.SetStartConfig
func (mmSetStartConfig *mStoreMockSetStartConfig) Expect(c1 payloads.Configuration) *mStoreMockSetStartConfig {
	if mmSetStartConfig.mock.funcSetStartConfig != nil {
		mmSetStartConfig.mock.t.Fatalf("StoreMock.SetStartConfig mock is already set by Set")
	}

	if mmSetStartConfig.defaultExpectation == nil {
		mmSetStartConfig.defaultExpectation = &StoreMockSetStartConfigExpectation{}
	}

	mmSetStartConfig.defaultExpectation.params = &StoreMockSetStartConfigParams{c1}
	for _, e := range mmSetStartConfig.expectations {
		if minimock.Equal(e.params, mmSetStartConfig.defaultExpectation.params) {
			mmSetStartConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStartConfig.defaultExpectation.params)
		}
	}

	return mmSetStartConfig
}

// Return sets up results that will be returned by Store.SetStartConfig
func (mmSetStartConfig *mStoreMockSetStartConfig) Return(err error) *StoreMock {
	if mmSetStartConfig.mock.funcSetStartConfig != nil {
		mmSetStartConfig.mock.t.Fatalf("StoreMock.SetStartConfig mock is already set by Set")
	}

	if mmSetStartConfig.defaultExpectation == nil {
		mmSetStartConfig.defaultExpectation = &StoreMockSetStartConfigExpectation{mock: mmSetStartConfig.mock}
	}
	mmSetStartConfig.defaultExpectation.results = &StoreMockSetStartConfigResults{err}
	return mmSetStartConfig.mock
}

//Set uses given function f to mock the Store.SetStartConfig method
func (mmSetStartConfig *mStoreMockSetStartConfig) Set(f func(c1 payloads.Configuration) (err error)) *StoreMock {
	if mmSetStartConfig.defaultExpectation != nil {
		mmSetStartConfig.mock.t.Fatalf("Default expectation is already set for the Store.SetStartConfig method")
	}

	if len(mmSetStartConfig.expectations) > 0 {
		mmSetStartConfig.mock.t.Fatalf("Some expectations are already set for the Store.SetStartConfig method")
	}

	mmSetStartConfig.mock.funcSetStartConfig = f
	return mmSetStartConfig.mock
}

// When sets expectation for the Store.SetStartConfig which will trigger the result defined by the following
// Then helper
func (mmSetStartConfig *mStoreMockSetStartConfig) When(c1 payloads.Configuration) *StoreMockSetStartConfigExpectation {
	if mmSetStartConfig.mock.funcSetStartConfig != nil {
		mmSetStartConfig.mock.t.Fatalf("StoreMock.SetStartConfig mock is already set by Set")
	}

	expectation := &StoreMockSetStartConfigExpectation{
		mock:   mmSetStartConfig.mock,
		params: &StoreMockSetStartConfigParams{c1},
	}
	mmSetStartConfig.expectations = append(mmSetStartConfig.expectations, expectation)
	return expectation
}

// Then sets up Store.SetStartConfig return parameters for the expectation previously defined by the When method
func (e *StoreMockSetStartConfigExpectation) Then(err error) *StoreMock {
	e.results = &StoreMockSetStartConfigResults{err}
	return e.mock
}

// SetStartConfig implements Store
func (mmSetStartConfig *StoreMock) SetStartConfig(c1 payloads.Configuration) (err error) {
	mm_atomic.AddUint64(&mmSetStartConfig.beforeSetStartConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStartConfig.afterSetStartConfigCounter, 1)

	params := &StoreMockSetStartConfigParams{c1}

	// Record call args
	mmSetStartConfig.SetStartConfigMock.mutex.Lock()
	mmSetStartConfig.SetStartConfigMock.callArgs = append(mmSetStartConfig.SetStartConfigMock.callArgs, params)
	mmSetStartConfig.SetStartConfigMock.mutex.Unlock()

	for _, e := range mmSetStartConfig.SetStartConfigMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStartConfig.SetStartConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStartConfig.SetStartConfigMock.defaultExpectation.Counter, 1)
		want := mmSetStartConfig.SetStartConfigMock.defaultExpectation.params
		got := StoreMockSetStartConfigParams{c1}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetStartConfig.t.Errorf("StoreMock.SetStartConfig got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSetStartConfig.SetStartConfigMock.defaultExpectation.results
		if results == nil {
			mmSetStartConfig.t.Fatal("No results are set for the StoreMock.SetStartConfig")
		}
		return (*results).err
	}
	if mmSetStartConfig.funcSetStartConfig != nil {
		return mmSetStartConfig.funcSetStartConfig(c1)
	}
	mmSetStartConfig.t.Fatalf("Unexpected call to StoreMock.SetStartConfig. %v", c1)
	return
}

// SetStartConfigAfterCounter returns a count of finished StoreMock.SetStartConfig invocations
func (mmSetStartConfig *StoreMock) SetStartConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartConfig.afterSetStartConfigCounter)
}

// SetStartConfigBeforeCounter returns a count of StoreMock.SetStartConfig invocations
func (mmSetStartConfig *StoreMock) SetStartConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStartConfig.beforeSetStartConfigCounter)
}

// Calls returns a list of arguments used in each call to StoreMock.SetStartConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStartConfig *mStoreMockSetStartConfig) Calls() []*StoreMockSetStartConfigParams {
	mmSetStartConfig.mutex.RLock()

	argCopy := make([]*StoreMockSetStartConfigParams, len(mmSetStartConfig.callArgs))
	copy(argCopy, mmSetStartConfig.callArgs)

	mmSetStartConfig.mutex.RUnlock()

	return argCopy
}

// MinimockSetStartConfigDone returns true if the count of the SetStartConfig invocations corresponds
// the number of defined expectations
func (m *StoreMock) MinimockSetStartConfigDone() bool {
	for _, e := range m.SetStartConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartConfig != nil && mm_atomic.LoadUint64(&m.afterSetStartConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStartConfigInspect logs each unmet expectation
func (m *StoreMock) MinimockSetStartConfigInspect() {
	for _, e := range m.SetStartConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StoreMock.SetStartConfig with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStartConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStartConfigCounter) < 1 {
		if m.SetStartConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StoreMock.SetStartConfig")
		} else {
			m.t.Errorf("Expected call to StoreMock.SetStartConfig with params: %#v", *m.SetStartConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStartConfig != nil && mm_atomic.LoadUint64(&m.afterSetStartConfigCounter) < 1 {
		m.t.Error("Expected call to StoreMock.SetStartConfig")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteModuleByIDInspect()

		m.MinimockInsertModulesInspect()

		m.MinimockListHeartbeatsInspect()

		m.MinimockListModuleIDsInspect()

		m.MinimockListModulesInspect()

		m.MinimockListModulesByIDsInspect()

		m.MinimockListModulesBySourceInspect()

		m.MinimockListStartConfigsInspect()

		m.MinimockPurgeProxyInspect()

		m.MinimockSetHeartbeatInspect()

		m.MinimockSetStartConfigInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteModuleByIDDone() &&
		m.MinimockInsertModulesDone() &&
		m.MinimockListHeartbeatsDone() &&
		m.MinimockListModuleIDsDone() &&
		m.MinimockListModulesDone() &&
		m.MinimockListModulesByIDsDone() &&
		m.MinimockListModulesBySourceDone() &&
		m.MinimockListStartConfigsDone() &&
		m.MinimockPurgeProxyDone() &&
		m.MinimockSetHeartbeatDone() &&
		m.MinimockSetStartConfigDone()
}
