package store

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"oss.indeed.com/go/modprox/pkg/coordinates"
	"oss.indeed.com/go/modprox/pkg/repository"
)

// IndexMock implements Index
type IndexMock struct {
	t minimock.Tester

	funcContains          func(m1 coordinates.Module) (b1 bool, i1 int64, err error)
	afterContainsCounter  uint64
	beforeContainsCounter uint64
	ContainsMock          mIndexMockContains

	funcIDs          func() (r1 Ranges, err error)
	afterIDsCounter  uint64
	beforeIDsCounter uint64
	IDsMock          mIndexMockIDs

	funcInfo          func(m1 coordinates.Module) (r1 repository.RevInfo, err error)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mIndexMockInfo

	funcMod          func(m1 coordinates.Module) (s1 string, err error)
	afterModCounter  uint64
	beforeModCounter uint64
	ModMock          mIndexMockMod

	funcPut          func(m1 ModuleAddition) (err error)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mIndexMockPut

	funcRemove          func(m1 coordinates.Module) (err error)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mIndexMockRemove

	funcSummary          func() (i1 int, i2 int, err error)
	afterSummaryCounter  uint64
	beforeSummaryCounter uint64
	SummaryMock          mIndexMockSummary

	funcUpdateID          func(s1 coordinates.SerialModule) (err error)
	afterUpdateIDCounter  uint64
	beforeUpdateIDCounter uint64
	UpdateIDMock          mIndexMockUpdateID

	funcVersions          func(module string) (sa1 []string, err error)
	afterVersionsCounter  uint64
	beforeVersionsCounter uint64
	VersionsMock          mIndexMockVersions
}

// NewIndexMock returns a mock for Index
func NewIndexMock(t minimock.Tester) *IndexMock {
	m := &IndexMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	m.ContainsMock = mIndexMockContains{mock: m}
	m.IDsMock = mIndexMockIDs{mock: m}
	m.InfoMock = mIndexMockInfo{mock: m}
	m.ModMock = mIndexMockMod{mock: m}
	m.PutMock = mIndexMockPut{mock: m}
	m.RemoveMock = mIndexMockRemove{mock: m}
	m.SummaryMock = mIndexMockSummary{mock: m}
	m.UpdateIDMock = mIndexMockUpdateID{mock: m}
	m.VersionsMock = mIndexMockVersions{mock: m}

	return m
}

type mIndexMockContains struct {
	mock               *IndexMock
	defaultExpectation *IndexMockContainsExpectation
	expectations       []*IndexMockContainsExpectation
}

// IndexMockContainsExpectation specifies expectation struct of the Index.Contains
type IndexMockContainsExpectation struct {
	mock    *IndexMock
	params  *IndexMockContainsParams
	results *IndexMockContainsResults
	Counter uint64
}

// IndexMockContainsParams contains parameters of the Index.Contains
type IndexMockContainsParams struct {
	m1 coordinates.Module
}

// IndexMockContainsResults contains results of the Index.Contains
type IndexMockContainsResults struct {
	b1  bool
	i1  int64
	err error
}

// Expect sets up expected params for Index.Contains
func (m *mIndexMockContains) Expect(m1 coordinates.Module) *mIndexMockContains {
	if m.mock.funcContains != nil {
		m.mock.t.Fatalf("IndexMock.Contains mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockContainsExpectation{}
	}

	m.defaultExpectation.params = &IndexMockContainsParams{m1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Contains
func (m *mIndexMockContains) Return(b1 bool, i1 int64, err error) *IndexMock {
	if m.mock.funcContains != nil {
		m.mock.t.Fatalf("IndexMock.Contains mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockContainsExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockContainsResults{b1, i1, err}
	return m.mock
}

//Set uses given function f to mock the Index.Contains method
func (m *mIndexMockContains) Set(f func(m1 coordinates.Module) (b1 bool, i1 int64, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Contains method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Contains method")
	}

	m.mock.funcContains = f
	return m.mock
}

// When sets expectation for the Index.Contains which will trigger the result defined by the following
// Then helper
func (m *mIndexMockContains) When(m1 coordinates.Module) *IndexMockContainsExpectation {
	if m.mock.funcContains != nil {
		m.mock.t.Fatalf("IndexMock.Contains mock is already set by Set")
	}

	expectation := &IndexMockContainsExpectation{
		mock:   m.mock,
		params: &IndexMockContainsParams{m1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Contains return parameters for the expectation previously defined by the When method
func (e *IndexMockContainsExpectation) Then(b1 bool, i1 int64, err error) *IndexMock {
	e.results = &IndexMockContainsResults{b1, i1, err}
	return e.mock
}

// Contains implements Index
func (m *IndexMock) Contains(m1 coordinates.Module) (b1 bool, i1 int64, err error) {
	mm_atomic.AddUint64(&m.beforeContainsCounter, 1)
	defer mm_atomic.AddUint64(&m.afterContainsCounter, 1)

	for _, e := range m.ContainsMock.expectations {
		if minimock.Equal(*e.params, IndexMockContainsParams{m1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.i1, e.results.err
		}
	}

	if m.ContainsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ContainsMock.defaultExpectation.Counter, 1)
		want := m.ContainsMock.defaultExpectation.params
		got := IndexMockContainsParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Contains got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ContainsMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Contains")
		}
		return (*results).b1, (*results).i1, (*results).err
	}
	if m.funcContains != nil {
		return m.funcContains(m1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Contains. %v", m1)
	return
}

// ContainsAfterCounter returns a count of finished IndexMock.Contains invocations
func (m *IndexMock) ContainsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterContainsCounter)
}

// ContainsBeforeCounter returns a count of IndexMock.Contains invocations
func (m *IndexMock) ContainsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeContainsCounter)
}

// MinimockContainsDone returns true if the count of the Contains invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockContainsDone() bool {
	for _, e := range m.ContainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContains != nil && mm_atomic.LoadUint64(&m.afterContainsCounter) < 1 {
		return false
	}
	return true
}

// MinimockContainsInspect logs each unmet expectation
func (m *IndexMock) MinimockContainsInspect() {
	for _, e := range m.ContainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Contains with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContainsCounter) < 1 {
		if m.ContainsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Contains")
		} else {
			m.t.Errorf("Expected call to IndexMock.Contains with params: %#v", *m.ContainsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContains != nil && mm_atomic.LoadUint64(&m.afterContainsCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Contains")
	}
}

type mIndexMockIDs struct {
	mock               *IndexMock
	defaultExpectation *IndexMockIDsExpectation
	expectations       []*IndexMockIDsExpectation
}

// IndexMockIDsExpectation specifies expectation struct of the Index.IDs
type IndexMockIDsExpectation struct {
	mock *IndexMock

	results *IndexMockIDsResults
	Counter uint64
}

// IndexMockIDsResults contains results of the Index.IDs
type IndexMockIDsResults struct {
	r1  Ranges
	err error
}

// Expect sets up expected params for Index.IDs
func (m *mIndexMockIDs) Expect() *mIndexMockIDs {
	if m.mock.funcIDs != nil {
		m.mock.t.Fatalf("IndexMock.IDs mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockIDsExpectation{}
	}

	return m
}

// Return sets up results that will be returned by Index.IDs
func (m *mIndexMockIDs) Return(r1 Ranges, err error) *IndexMock {
	if m.mock.funcIDs != nil {
		m.mock.t.Fatalf("IndexMock.IDs mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockIDsExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockIDsResults{r1, err}
	return m.mock
}

//Set uses given function f to mock the Index.IDs method
func (m *mIndexMockIDs) Set(f func() (r1 Ranges, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.IDs method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.IDs method")
	}

	m.mock.funcIDs = f
	return m.mock
}

// IDs implements Index
func (m *IndexMock) IDs() (r1 Ranges, err error) {
	mm_atomic.AddUint64(&m.beforeIDsCounter, 1)
	defer mm_atomic.AddUint64(&m.afterIDsCounter, 1)

	if m.IDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.IDsMock.defaultExpectation.Counter, 1)

		results := m.IDsMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.IDs")
		}
		return (*results).r1, (*results).err
	}
	if m.funcIDs != nil {
		return m.funcIDs()
	}
	m.t.Fatalf("Unexpected call to IndexMock.IDs.")
	return
}

// IDsAfterCounter returns a count of finished IndexMock.IDs invocations
func (m *IndexMock) IDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterIDsCounter)
}

// IDsBeforeCounter returns a count of IndexMock.IDs invocations
func (m *IndexMock) IDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeIDsCounter)
}

// MinimockIDsDone returns true if the count of the IDs invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockIDsDone() bool {
	for _, e := range m.IDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIDs != nil && mm_atomic.LoadUint64(&m.afterIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIDsInspect logs each unmet expectation
func (m *IndexMock) MinimockIDsInspect() {
	for _, e := range m.IDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexMock.IDs")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDsCounter) < 1 {
		m.t.Error("Expected call to IndexMock.IDs")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIDs != nil && mm_atomic.LoadUint64(&m.afterIDsCounter) < 1 {
		m.t.Error("Expected call to IndexMock.IDs")
	}
}

type mIndexMockInfo struct {
	mock               *IndexMock
	defaultExpectation *IndexMockInfoExpectation
	expectations       []*IndexMockInfoExpectation
}

// IndexMockInfoExpectation specifies expectation struct of the Index.Info
type IndexMockInfoExpectation struct {
	mock    *IndexMock
	params  *IndexMockInfoParams
	results *IndexMockInfoResults
	Counter uint64
}

// IndexMockInfoParams contains parameters of the Index.Info
type IndexMockInfoParams struct {
	m1 coordinates.Module
}

// IndexMockInfoResults contains results of the Index.Info
type IndexMockInfoResults struct {
	r1  repository.RevInfo
	err error
}

// Expect sets up expected params for Index.Info
func (m *mIndexMockInfo) Expect(m1 coordinates.Module) *mIndexMockInfo {
	if m.mock.funcInfo != nil {
		m.mock.t.Fatalf("IndexMock.Info mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockInfoExpectation{}
	}

	m.defaultExpectation.params = &IndexMockInfoParams{m1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Info
func (m *mIndexMockInfo) Return(r1 repository.RevInfo, err error) *IndexMock {
	if m.mock.funcInfo != nil {
		m.mock.t.Fatalf("IndexMock.Info mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockInfoExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockInfoResults{r1, err}
	return m.mock
}

//Set uses given function f to mock the Index.Info method
func (m *mIndexMockInfo) Set(f func(m1 coordinates.Module) (r1 repository.RevInfo, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Info method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Info method")
	}

	m.mock.funcInfo = f
	return m.mock
}

// When sets expectation for the Index.Info which will trigger the result defined by the following
// Then helper
func (m *mIndexMockInfo) When(m1 coordinates.Module) *IndexMockInfoExpectation {
	if m.mock.funcInfo != nil {
		m.mock.t.Fatalf("IndexMock.Info mock is already set by Set")
	}

	expectation := &IndexMockInfoExpectation{
		mock:   m.mock,
		params: &IndexMockInfoParams{m1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Info return parameters for the expectation previously defined by the When method
func (e *IndexMockInfoExpectation) Then(r1 repository.RevInfo, err error) *IndexMock {
	e.results = &IndexMockInfoResults{r1, err}
	return e.mock
}

// Info implements Index
func (m *IndexMock) Info(m1 coordinates.Module) (r1 repository.RevInfo, err error) {
	mm_atomic.AddUint64(&m.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&m.afterInfoCounter, 1)

	for _, e := range m.InfoMock.expectations {
		if minimock.Equal(*e.params, IndexMockInfoParams{m1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if m.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.InfoMock.defaultExpectation.Counter, 1)
		want := m.InfoMock.defaultExpectation.params
		got := IndexMockInfoParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.InfoMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Info")
		}
		return (*results).r1, (*results).err
	}
	if m.funcInfo != nil {
		return m.funcInfo(m1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Info. %v", m1)
	return
}

// InfoAfterCounter returns a count of finished IndexMock.Info invocations
func (m *IndexMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterInfoCounter)
}

// InfoBeforeCounter returns a count of IndexMock.Info invocations
func (m *IndexMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeInfoCounter)
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *IndexMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Info")
		} else {
			m.t.Errorf("Expected call to IndexMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Info")
	}
}

type mIndexMockMod struct {
	mock               *IndexMock
	defaultExpectation *IndexMockModExpectation
	expectations       []*IndexMockModExpectation
}

// IndexMockModExpectation specifies expectation struct of the Index.Mod
type IndexMockModExpectation struct {
	mock    *IndexMock
	params  *IndexMockModParams
	results *IndexMockModResults
	Counter uint64
}

// IndexMockModParams contains parameters of the Index.Mod
type IndexMockModParams struct {
	m1 coordinates.Module
}

// IndexMockModResults contains results of the Index.Mod
type IndexMockModResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Index.Mod
func (m *mIndexMockMod) Expect(m1 coordinates.Module) *mIndexMockMod {
	if m.mock.funcMod != nil {
		m.mock.t.Fatalf("IndexMock.Mod mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockModExpectation{}
	}

	m.defaultExpectation.params = &IndexMockModParams{m1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Mod
func (m *mIndexMockMod) Return(s1 string, err error) *IndexMock {
	if m.mock.funcMod != nil {
		m.mock.t.Fatalf("IndexMock.Mod mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockModExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockModResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the Index.Mod method
func (m *mIndexMockMod) Set(f func(m1 coordinates.Module) (s1 string, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Mod method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Mod method")
	}

	m.mock.funcMod = f
	return m.mock
}

// When sets expectation for the Index.Mod which will trigger the result defined by the following
// Then helper
func (m *mIndexMockMod) When(m1 coordinates.Module) *IndexMockModExpectation {
	if m.mock.funcMod != nil {
		m.mock.t.Fatalf("IndexMock.Mod mock is already set by Set")
	}

	expectation := &IndexMockModExpectation{
		mock:   m.mock,
		params: &IndexMockModParams{m1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Mod return parameters for the expectation previously defined by the When method
func (e *IndexMockModExpectation) Then(s1 string, err error) *IndexMock {
	e.results = &IndexMockModResults{s1, err}
	return e.mock
}

// Mod implements Index
func (m *IndexMock) Mod(m1 coordinates.Module) (s1 string, err error) {
	mm_atomic.AddUint64(&m.beforeModCounter, 1)
	defer mm_atomic.AddUint64(&m.afterModCounter, 1)

	for _, e := range m.ModMock.expectations {
		if minimock.Equal(*e.params, IndexMockModParams{m1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.ModMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ModMock.defaultExpectation.Counter, 1)
		want := m.ModMock.defaultExpectation.params
		got := IndexMockModParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Mod got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ModMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Mod")
		}
		return (*results).s1, (*results).err
	}
	if m.funcMod != nil {
		return m.funcMod(m1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Mod. %v", m1)
	return
}

// ModAfterCounter returns a count of finished IndexMock.Mod invocations
func (m *IndexMock) ModAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterModCounter)
}

// ModBeforeCounter returns a count of IndexMock.Mod invocations
func (m *IndexMock) ModBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeModCounter)
}

// MinimockModDone returns true if the count of the Mod invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockModDone() bool {
	for _, e := range m.ModMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ModMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterModCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMod != nil && mm_atomic.LoadUint64(&m.afterModCounter) < 1 {
		return false
	}
	return true
}

// MinimockModInspect logs each unmet expectation
func (m *IndexMock) MinimockModInspect() {
	for _, e := range m.ModMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Mod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ModMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterModCounter) < 1 {
		if m.ModMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Mod")
		} else {
			m.t.Errorf("Expected call to IndexMock.Mod with params: %#v", *m.ModMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMod != nil && mm_atomic.LoadUint64(&m.afterModCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Mod")
	}
}

type mIndexMockPut struct {
	mock               *IndexMock
	defaultExpectation *IndexMockPutExpectation
	expectations       []*IndexMockPutExpectation
}

// IndexMockPutExpectation specifies expectation struct of the Index.Put
type IndexMockPutExpectation struct {
	mock    *IndexMock
	params  *IndexMockPutParams
	results *IndexMockPutResults
	Counter uint64
}

// IndexMockPutParams contains parameters of the Index.Put
type IndexMockPutParams struct {
	m1 ModuleAddition
}

// IndexMockPutResults contains results of the Index.Put
type IndexMockPutResults struct {
	err error
}

// Expect sets up expected params for Index.Put
func (m *mIndexMockPut) Expect(m1 ModuleAddition) *mIndexMockPut {
	if m.mock.funcPut != nil {
		m.mock.t.Fatalf("IndexMock.Put mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockPutExpectation{}
	}

	m.defaultExpectation.params = &IndexMockPutParams{m1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Put
func (m *mIndexMockPut) Return(err error) *IndexMock {
	if m.mock.funcPut != nil {
		m.mock.t.Fatalf("IndexMock.Put mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockPutExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockPutResults{err}
	return m.mock
}

//Set uses given function f to mock the Index.Put method
func (m *mIndexMockPut) Set(f func(m1 ModuleAddition) (err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Put method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Put method")
	}

	m.mock.funcPut = f
	return m.mock
}

// When sets expectation for the Index.Put which will trigger the result defined by the following
// Then helper
func (m *mIndexMockPut) When(m1 ModuleAddition) *IndexMockPutExpectation {
	if m.mock.funcPut != nil {
		m.mock.t.Fatalf("IndexMock.Put mock is already set by Set")
	}

	expectation := &IndexMockPutExpectation{
		mock:   m.mock,
		params: &IndexMockPutParams{m1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Put return parameters for the expectation previously defined by the When method
func (e *IndexMockPutExpectation) Then(err error) *IndexMock {
	e.results = &IndexMockPutResults{err}
	return e.mock
}

// Put implements Index
func (m *IndexMock) Put(m1 ModuleAddition) (err error) {
	mm_atomic.AddUint64(&m.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&m.afterPutCounter, 1)

	for _, e := range m.PutMock.expectations {
		if minimock.Equal(*e.params, IndexMockPutParams{m1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.PutMock.defaultExpectation.Counter, 1)
		want := m.PutMock.defaultExpectation.params
		got := IndexMockPutParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.PutMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Put")
		}
		return (*results).err
	}
	if m.funcPut != nil {
		return m.funcPut(m1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Put. %v", m1)
	return
}

// PutAfterCounter returns a count of finished IndexMock.Put invocations
func (m *IndexMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterPutCounter)
}

// PutBeforeCounter returns a count of IndexMock.Put invocations
func (m *IndexMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforePutCounter)
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *IndexMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Put")
		} else {
			m.t.Errorf("Expected call to IndexMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Put")
	}
}

type mIndexMockRemove struct {
	mock               *IndexMock
	defaultExpectation *IndexMockRemoveExpectation
	expectations       []*IndexMockRemoveExpectation
}

// IndexMockRemoveExpectation specifies expectation struct of the Index.Remove
type IndexMockRemoveExpectation struct {
	mock    *IndexMock
	params  *IndexMockRemoveParams
	results *IndexMockRemoveResults
	Counter uint64
}

// IndexMockRemoveParams contains parameters of the Index.Remove
type IndexMockRemoveParams struct {
	m1 coordinates.Module
}

// IndexMockRemoveResults contains results of the Index.Remove
type IndexMockRemoveResults struct {
	err error
}

// Expect sets up expected params for Index.Remove
func (m *mIndexMockRemove) Expect(m1 coordinates.Module) *mIndexMockRemove {
	if m.mock.funcRemove != nil {
		m.mock.t.Fatalf("IndexMock.Remove mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockRemoveExpectation{}
	}

	m.defaultExpectation.params = &IndexMockRemoveParams{m1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Remove
func (m *mIndexMockRemove) Return(err error) *IndexMock {
	if m.mock.funcRemove != nil {
		m.mock.t.Fatalf("IndexMock.Remove mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockRemoveExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockRemoveResults{err}
	return m.mock
}

//Set uses given function f to mock the Index.Remove method
func (m *mIndexMockRemove) Set(f func(m1 coordinates.Module) (err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Remove method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Remove method")
	}

	m.mock.funcRemove = f
	return m.mock
}

// When sets expectation for the Index.Remove which will trigger the result defined by the following
// Then helper
func (m *mIndexMockRemove) When(m1 coordinates.Module) *IndexMockRemoveExpectation {
	if m.mock.funcRemove != nil {
		m.mock.t.Fatalf("IndexMock.Remove mock is already set by Set")
	}

	expectation := &IndexMockRemoveExpectation{
		mock:   m.mock,
		params: &IndexMockRemoveParams{m1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Remove return parameters for the expectation previously defined by the When method
func (e *IndexMockRemoveExpectation) Then(err error) *IndexMock {
	e.results = &IndexMockRemoveResults{err}
	return e.mock
}

// Remove implements Index
func (m *IndexMock) Remove(m1 coordinates.Module) (err error) {
	mm_atomic.AddUint64(&m.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&m.afterRemoveCounter, 1)

	for _, e := range m.RemoveMock.expectations {
		if minimock.Equal(*e.params, IndexMockRemoveParams{m1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.RemoveMock.defaultExpectation.Counter, 1)
		want := m.RemoveMock.defaultExpectation.params
		got := IndexMockRemoveParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Remove got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.RemoveMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Remove")
		}
		return (*results).err
	}
	if m.funcRemove != nil {
		return m.funcRemove(m1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Remove. %v", m1)
	return
}

// RemoveAfterCounter returns a count of finished IndexMock.Remove invocations
func (m *IndexMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of IndexMock.Remove invocations
func (m *IndexMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeRemoveCounter)
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockRemoveDone() bool {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveInspect logs each unmet expectation
func (m *IndexMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Remove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Remove")
		} else {
			m.t.Errorf("Expected call to IndexMock.Remove with params: %#v", *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Remove")
	}
}

type mIndexMockSummary struct {
	mock               *IndexMock
	defaultExpectation *IndexMockSummaryExpectation
	expectations       []*IndexMockSummaryExpectation
}

// IndexMockSummaryExpectation specifies expectation struct of the Index.Summary
type IndexMockSummaryExpectation struct {
	mock *IndexMock

	results *IndexMockSummaryResults
	Counter uint64
}

// IndexMockSummaryResults contains results of the Index.Summary
type IndexMockSummaryResults struct {
	i1  int
	i2  int
	err error
}

// Expect sets up expected params for Index.Summary
func (m *mIndexMockSummary) Expect() *mIndexMockSummary {
	if m.mock.funcSummary != nil {
		m.mock.t.Fatalf("IndexMock.Summary mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockSummaryExpectation{}
	}

	return m
}

// Return sets up results that will be returned by Index.Summary
func (m *mIndexMockSummary) Return(i1 int, i2 int, err error) *IndexMock {
	if m.mock.funcSummary != nil {
		m.mock.t.Fatalf("IndexMock.Summary mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockSummaryExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockSummaryResults{i1, i2, err}
	return m.mock
}

//Set uses given function f to mock the Index.Summary method
func (m *mIndexMockSummary) Set(f func() (i1 int, i2 int, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Summary method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Summary method")
	}

	m.mock.funcSummary = f
	return m.mock
}

// Summary implements Index
func (m *IndexMock) Summary() (i1 int, i2 int, err error) {
	mm_atomic.AddUint64(&m.beforeSummaryCounter, 1)
	defer mm_atomic.AddUint64(&m.afterSummaryCounter, 1)

	if m.SummaryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.SummaryMock.defaultExpectation.Counter, 1)

		results := m.SummaryMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Summary")
		}
		return (*results).i1, (*results).i2, (*results).err
	}
	if m.funcSummary != nil {
		return m.funcSummary()
	}
	m.t.Fatalf("Unexpected call to IndexMock.Summary.")
	return
}

// SummaryAfterCounter returns a count of finished IndexMock.Summary invocations
func (m *IndexMock) SummaryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterSummaryCounter)
}

// SummaryBeforeCounter returns a count of IndexMock.Summary invocations
func (m *IndexMock) SummaryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeSummaryCounter)
}

// MinimockSummaryDone returns true if the count of the Summary invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockSummaryDone() bool {
	for _, e := range m.SummaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SummaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSummaryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSummary != nil && mm_atomic.LoadUint64(&m.afterSummaryCounter) < 1 {
		return false
	}
	return true
}

// MinimockSummaryInspect logs each unmet expectation
func (m *IndexMock) MinimockSummaryInspect() {
	for _, e := range m.SummaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IndexMock.Summary")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SummaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSummaryCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Summary")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSummary != nil && mm_atomic.LoadUint64(&m.afterSummaryCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Summary")
	}
}

type mIndexMockUpdateID struct {
	mock               *IndexMock
	defaultExpectation *IndexMockUpdateIDExpectation
	expectations       []*IndexMockUpdateIDExpectation
}

// IndexMockUpdateIDExpectation specifies expectation struct of the Index.UpdateID
type IndexMockUpdateIDExpectation struct {
	mock    *IndexMock
	params  *IndexMockUpdateIDParams
	results *IndexMockUpdateIDResults
	Counter uint64
}

// IndexMockUpdateIDParams contains parameters of the Index.UpdateID
type IndexMockUpdateIDParams struct {
	s1 coordinates.SerialModule
}

// IndexMockUpdateIDResults contains results of the Index.UpdateID
type IndexMockUpdateIDResults struct {
	err error
}

// Expect sets up expected params for Index.UpdateID
func (m *mIndexMockUpdateID) Expect(s1 coordinates.SerialModule) *mIndexMockUpdateID {
	if m.mock.funcUpdateID != nil {
		m.mock.t.Fatalf("IndexMock.UpdateID mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockUpdateIDExpectation{}
	}

	m.defaultExpectation.params = &IndexMockUpdateIDParams{s1}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.UpdateID
func (m *mIndexMockUpdateID) Return(err error) *IndexMock {
	if m.mock.funcUpdateID != nil {
		m.mock.t.Fatalf("IndexMock.UpdateID mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockUpdateIDExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockUpdateIDResults{err}
	return m.mock
}

//Set uses given function f to mock the Index.UpdateID method
func (m *mIndexMockUpdateID) Set(f func(s1 coordinates.SerialModule) (err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.UpdateID method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.UpdateID method")
	}

	m.mock.funcUpdateID = f
	return m.mock
}

// When sets expectation for the Index.UpdateID which will trigger the result defined by the following
// Then helper
func (m *mIndexMockUpdateID) When(s1 coordinates.SerialModule) *IndexMockUpdateIDExpectation {
	if m.mock.funcUpdateID != nil {
		m.mock.t.Fatalf("IndexMock.UpdateID mock is already set by Set")
	}

	expectation := &IndexMockUpdateIDExpectation{
		mock:   m.mock,
		params: &IndexMockUpdateIDParams{s1},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.UpdateID return parameters for the expectation previously defined by the When method
func (e *IndexMockUpdateIDExpectation) Then(err error) *IndexMock {
	e.results = &IndexMockUpdateIDResults{err}
	return e.mock
}

// UpdateID implements Index
func (m *IndexMock) UpdateID(s1 coordinates.SerialModule) (err error) {
	mm_atomic.AddUint64(&m.beforeUpdateIDCounter, 1)
	defer mm_atomic.AddUint64(&m.afterUpdateIDCounter, 1)

	for _, e := range m.UpdateIDMock.expectations {
		if minimock.Equal(*e.params, IndexMockUpdateIDParams{s1}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.UpdateIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.UpdateIDMock.defaultExpectation.Counter, 1)
		want := m.UpdateIDMock.defaultExpectation.params
		got := IndexMockUpdateIDParams{s1}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.UpdateID got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.UpdateIDMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.UpdateID")
		}
		return (*results).err
	}
	if m.funcUpdateID != nil {
		return m.funcUpdateID(s1)
	}
	m.t.Fatalf("Unexpected call to IndexMock.UpdateID. %v", s1)
	return
}

// UpdateIDAfterCounter returns a count of finished IndexMock.UpdateID invocations
func (m *IndexMock) UpdateIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterUpdateIDCounter)
}

// UpdateIDBeforeCounter returns a count of IndexMock.UpdateID invocations
func (m *IndexMock) UpdateIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeUpdateIDCounter)
}

// MinimockUpdateIDDone returns true if the count of the UpdateID invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockUpdateIDDone() bool {
	for _, e := range m.UpdateIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateID != nil && mm_atomic.LoadUint64(&m.afterUpdateIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateIDInspect logs each unmet expectation
func (m *IndexMock) MinimockUpdateIDInspect() {
	for _, e := range m.UpdateIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.UpdateID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateIDCounter) < 1 {
		if m.UpdateIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.UpdateID")
		} else {
			m.t.Errorf("Expected call to IndexMock.UpdateID with params: %#v", *m.UpdateIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateID != nil && mm_atomic.LoadUint64(&m.afterUpdateIDCounter) < 1 {
		m.t.Error("Expected call to IndexMock.UpdateID")
	}
}

type mIndexMockVersions struct {
	mock               *IndexMock
	defaultExpectation *IndexMockVersionsExpectation
	expectations       []*IndexMockVersionsExpectation
}

// IndexMockVersionsExpectation specifies expectation struct of the Index.Versions
type IndexMockVersionsExpectation struct {
	mock    *IndexMock
	params  *IndexMockVersionsParams
	results *IndexMockVersionsResults
	Counter uint64
}

// IndexMockVersionsParams contains parameters of the Index.Versions
type IndexMockVersionsParams struct {
	module string
}

// IndexMockVersionsResults contains results of the Index.Versions
type IndexMockVersionsResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Index.Versions
func (m *mIndexMockVersions) Expect(module string) *mIndexMockVersions {
	if m.mock.funcVersions != nil {
		m.mock.t.Fatalf("IndexMock.Versions mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockVersionsExpectation{}
	}

	m.defaultExpectation.params = &IndexMockVersionsParams{module}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Index.Versions
func (m *mIndexMockVersions) Return(sa1 []string, err error) *IndexMock {
	if m.mock.funcVersions != nil {
		m.mock.t.Fatalf("IndexMock.Versions mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &IndexMockVersionsExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &IndexMockVersionsResults{sa1, err}
	return m.mock
}

//Set uses given function f to mock the Index.Versions method
func (m *mIndexMockVersions) Set(f func(module string) (sa1 []string, err error)) *IndexMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Index.Versions method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Index.Versions method")
	}

	m.mock.funcVersions = f
	return m.mock
}

// When sets expectation for the Index.Versions which will trigger the result defined by the following
// Then helper
func (m *mIndexMockVersions) When(module string) *IndexMockVersionsExpectation {
	if m.mock.funcVersions != nil {
		m.mock.t.Fatalf("IndexMock.Versions mock is already set by Set")
	}

	expectation := &IndexMockVersionsExpectation{
		mock:   m.mock,
		params: &IndexMockVersionsParams{module},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Index.Versions return parameters for the expectation previously defined by the When method
func (e *IndexMockVersionsExpectation) Then(sa1 []string, err error) *IndexMock {
	e.results = &IndexMockVersionsResults{sa1, err}
	return e.mock
}

// Versions implements Index
func (m *IndexMock) Versions(module string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&m.beforeVersionsCounter, 1)
	defer mm_atomic.AddUint64(&m.afterVersionsCounter, 1)

	for _, e := range m.VersionsMock.expectations {
		if minimock.Equal(*e.params, IndexMockVersionsParams{module}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if m.VersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.VersionsMock.defaultExpectation.Counter, 1)
		want := m.VersionsMock.defaultExpectation.params
		got := IndexMockVersionsParams{module}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("IndexMock.Versions got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.VersionsMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the IndexMock.Versions")
		}
		return (*results).sa1, (*results).err
	}
	if m.funcVersions != nil {
		return m.funcVersions(module)
	}
	m.t.Fatalf("Unexpected call to IndexMock.Versions. %v", module)
	return
}

// VersionsAfterCounter returns a count of finished IndexMock.Versions invocations
func (m *IndexMock) VersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterVersionsCounter)
}

// VersionsBeforeCounter returns a count of IndexMock.Versions invocations
func (m *IndexMock) VersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeVersionsCounter)
}

// MinimockVersionsDone returns true if the count of the Versions invocations corresponds
// the number of defined expectations
func (m *IndexMock) MinimockVersionsDone() bool {
	for _, e := range m.VersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VersionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVersionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVersions != nil && mm_atomic.LoadUint64(&m.afterVersionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockVersionsInspect logs each unmet expectation
func (m *IndexMock) MinimockVersionsInspect() {
	for _, e := range m.VersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexMock.Versions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VersionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVersionsCounter) < 1 {
		if m.VersionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexMock.Versions")
		} else {
			m.t.Errorf("Expected call to IndexMock.Versions with params: %#v", *m.VersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVersions != nil && mm_atomic.LoadUint64(&m.afterVersionsCounter) < 1 {
		m.t.Error("Expected call to IndexMock.Versions")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IndexMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContainsInspect()

		m.MinimockIDsInspect()

		m.MinimockInfoInspect()

		m.MinimockModInspect()

		m.MinimockPutInspect()

		m.MinimockRemoveInspect()

		m.MinimockSummaryInspect()

		m.MinimockUpdateIDInspect()

		m.MinimockVersionsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IndexMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IndexMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContainsDone() &&
		m.MinimockIDsDone() &&
		m.MinimockInfoDone() &&
		m.MinimockModDone() &&
		m.MinimockPutDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockSummaryDone() &&
		m.MinimockUpdateIDDone() &&
		m.MinimockVersionsDone()
}
